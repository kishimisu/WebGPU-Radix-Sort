{"version":3,"file":"radix-sort-umd.min.js","sources":["../../src/shaders/prefix_sum.js","../../src/PrefixSumKernel.js","../../src/shaders/optimizations/prefix_sum_no_bank_conflict.js","../../src/shaders/radix_sort_reorder.js","../../src/RadixSortKernel.js","../../src/shaders/optimizations/radix_sort_local_shuffle.js","../../src/shaders/radix_sort.js"],"sourcesContent":["const prefixSumSource = /* wgsl */ `\r\n\r\n@group(0) @binding(0) var<storage, read_write> items: array<u32>;\r\n@group(0) @binding(1) var<storage, read_write> blockSums: array<u32>;\r\n\r\noverride WORKGROUP_SIZE_X: u32;\r\noverride WORKGROUP_SIZE_Y: u32;\r\noverride THREADS_PER_WORKGROUP: u32;\r\noverride ITEMS_PER_WORKGROUP: u32;\r\n\r\nvar<workgroup> temp: array<u32, ITEMS_PER_WORKGROUP*2>;\r\n\r\n@compute @workgroup_size(WORKGROUP_SIZE_X, WORKGROUP_SIZE_Y, 1)\r\nfn reduce_downsweep(\r\n    @builtin(workgroup_id) wid: vec3<u32>,\r\n    @builtin(local_invocation_index) TID: u32, // Local thread ID\r\n) {\r\n    let WID = wid.x * THREADS_PER_WORKGROUP;\r\n    let GID = WID + TID; // Global thread ID\r\n    \r\n    let ELM_TID = TID * 2; // Element pair local ID\r\n    let ELM_GID = GID * 2; // Element pair global ID\r\n    \r\n    // Load input to shared memory\r\n    temp[ELM_TID]     = items[ELM_GID];\r\n    temp[ELM_TID + 1] = items[ELM_GID + 1];\r\n\r\n    var offset: u32 = 1;\r\n\r\n    // Up-sweep (reduce) phase\r\n    for (var d: u32 = ITEMS_PER_WORKGROUP >> 1; d > 0; d >>= 1) {\r\n        workgroupBarrier();\r\n\r\n        if (TID < d) {\r\n            var ai: u32 = offset * (ELM_TID + 1) - 1;\r\n            var bi: u32 = offset * (ELM_TID + 2) - 1;\r\n            temp[bi] += temp[ai];\r\n        }\r\n\r\n        offset *= 2;\r\n    }\r\n\r\n    // Save workgroup sum and clear last element\r\n    if (TID == 0) {\r\n        let last_offset = ITEMS_PER_WORKGROUP - 1;\r\n\r\n        blockSums[wid.x] = temp[last_offset];\r\n        temp[last_offset] = 0;\r\n    }\r\n\r\n    // Down-sweep phase\r\n    for (var d: u32 = 1; d < ITEMS_PER_WORKGROUP; d *= 2) {\r\n        offset >>= 1;\r\n        workgroupBarrier();\r\n\r\n        if (TID < d) {\r\n            var ai: u32 = offset * (ELM_TID + 1) - 1;\r\n            var bi: u32 = offset * (ELM_TID + 2) - 1;\r\n\r\n            let t: u32 = temp[ai];\r\n            temp[ai] = temp[bi];\r\n            temp[bi] += t;\r\n        }\r\n    }\r\n    workgroupBarrier();\r\n\r\n    // Copy result from shared memory to global memory\r\n    items[ELM_GID]     = temp[ELM_TID];\r\n    items[ELM_GID + 1] = temp[ELM_TID + 1];\r\n}\r\n\r\n@compute @workgroup_size(WORKGROUP_SIZE_X, WORKGROUP_SIZE_Y, 1)\r\nfn add_block_sums(\r\n    @builtin(workgroup_id) wid: vec3<u32>,\r\n    @builtin(local_invocation_index) TID: u32, // Local thread ID\r\n) {\r\n    let GID = wid.x * THREADS_PER_WORKGROUP + TID; // Global thread ID\r\n\r\n    let ELM_ID = GID * 2;\r\n    let blockSum = blockSums[wid.x];\r\n\r\n    items[ELM_ID] += blockSum;\r\n    items[ELM_ID + 1] += blockSum;\r\n}`\r\n\r\nexport default prefixSumSource","import prefixSumSource from \"./shaders/prefix_sum\"\r\nimport prefixSumSource_NoBankConflict from \"./shaders/optimizations/prefix_sum_no_bank_conflict\"\r\n\r\nclass PrefixSumKernel {\r\n    /**\r\n     * Perform a parallel prefix sum on the given data buffer\r\n     * \r\n     * Based on \"Parallel Prefix Sum (Scan) with CUDA\"\r\n     * https://www.eecs.umich.edu/courses/eecs570/hw/parprefix.pdf\r\n     * \r\n     * @param {GPUDevice} device\r\n     * @param {GPUBuffer} data - Buffer containing the data to process\r\n     * @param {number} count - Max number of elements to process\r\n     * @param {object} workgroup_size - Workgroup size in x and y dimensions. (x * y) must be a power of two\r\n     * @param {boolean} avoid_bank_conflicts - Use the \"Avoid bank conflicts\" optimization from the original publication\r\n     */\r\n    constructor({\r\n        device,\r\n        data,\r\n        count,\r\n        workgroup_size = { x: 16, y: 16 },\r\n        avoid_bank_conflicts = false\r\n    }) {\r\n        this.device = device\r\n        this.workgroup_size = workgroup_size\r\n        this.threads_per_workgroup = workgroup_size.x * workgroup_size.y\r\n        this.items_per_workgroup = 2 * this.threads_per_workgroup // 2 items are processed per thread\r\n\r\n        if (Math.log2(this.threads_per_workgroup) % 1 !== 0) \r\n            throw new Error(`workgroup_size.x * workgroup_size.y must be a power of two. (current: ${this.threads_per_workgroup})`)\r\n\r\n        this.pipelines = []\r\n\r\n        this.shaderModule = this.device.createShaderModule({\r\n            label: 'prefix-sum',\r\n            code: avoid_bank_conflicts ? prefixSumSource_NoBankConflict : prefixSumSource,\r\n        })\r\n\r\n        this.create_pass_recursive(data, count)\r\n    }\r\n\r\n    create_pass_recursive(data, count) {\r\n        // Numbers of workgroups needed to process all items\r\n        const block_count = Math.ceil(count / this.items_per_workgroup)\r\n\r\n        // Create buffer for block sums\r\n        const blockSumBuffer = this.device.createBuffer({\r\n            size: block_count * 4,\r\n            usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST\r\n        })\r\n\r\n        // Create bind group and pipeline layout\r\n        const bindGroupLayout = this.device.createBindGroupLayout({\r\n            entries: [\r\n                {\r\n                    binding: 0,\r\n                    visibility: GPUShaderStage.COMPUTE,\r\n                    buffer: { type: 'storage' }\r\n                },\r\n                {\r\n                    binding: 1,\r\n                    visibility: GPUShaderStage.COMPUTE,\r\n                    buffer: { type: 'storage' }\r\n                }\r\n            ]\r\n        })\r\n\r\n        const bindGroup = this.device.createBindGroup({\r\n            label: 'prefix-sum-bind-group',\r\n            layout: bindGroupLayout,\r\n            entries: [\r\n                {\r\n                    binding: 0,\r\n                    resource: { buffer: data }\r\n                },\r\n                {\r\n                    binding: 1,\r\n                    resource: { buffer: blockSumBuffer }\r\n                }\r\n            ]\r\n        })\r\n\r\n        const pipelineLayout = this.device.createPipelineLayout({\r\n            bindGroupLayouts: [ bindGroupLayout ]\r\n        })\r\n\r\n        // Per-workgroup (block) prefix sum\r\n        const scanPipeline = this.device.createComputePipeline({\r\n            label: 'prefix-sum-scan-pipeline',\r\n            layout: pipelineLayout,\r\n            compute: {\r\n                module: this.shaderModule,\r\n                entryPoint: 'reduce_downsweep',\r\n                constants: {\r\n                    'WORKGROUP_SIZE_X': this.workgroup_size.x,\r\n                    'WORKGROUP_SIZE_Y': this.workgroup_size.y,\r\n                    'THREADS_PER_WORKGROUP': this.threads_per_workgroup,\r\n                    'ITEMS_PER_WORKGROUP': this.items_per_workgroup\r\n                }\r\n            }\r\n        })\r\n\r\n        this.pipelines.push({ pipeline: scanPipeline, bindGroup, block_count })\r\n\r\n        if (block_count > 1) {\r\n            // Prefix sum on block sums\r\n            this.create_pass_recursive(blockSumBuffer, block_count)\r\n\r\n            // Add block sums to local prefix sums\r\n            const blockSumPipeline = this.device.createComputePipeline({\r\n                label: 'prefix-sum-add-block-pipeline',\r\n                layout: pipelineLayout,\r\n                compute: {\r\n                    module: this.shaderModule,\r\n                    entryPoint: 'add_block_sums',\r\n                    constants: {\r\n                        'WORKGROUP_SIZE_X': this.workgroup_size.x,\r\n                        'WORKGROUP_SIZE_Y': this.workgroup_size.y,\r\n                        'THREADS_PER_WORKGROUP': this.threads_per_workgroup\r\n                    }\r\n                }\r\n            })\r\n\r\n            this.pipelines.push({ pipeline: blockSumPipeline, bindGroup, block_count })\r\n        }\r\n    }\r\n\r\n    dispatch(pass) {\r\n        for (const { pipeline, bindGroup, block_count } of this.pipelines) {\r\n            pass.setPipeline(pipeline)\r\n            pass.setBindGroup(0, bindGroup)\r\n            pass.dispatchWorkgroups(block_count)\r\n        }\r\n    }\r\n}\r\n\r\nexport default PrefixSumKernel","/**\r\n * Prefix sum with optimization to avoid bank conflicts\r\n * \r\n * (see Implementation section in README for details)\r\n */\r\nconst prefixSumNoBankConflictSource = /* wgsl */ `\r\n\r\n@group(0) @binding(0) var<storage, read_write> items: array<u32>;\r\n@group(0) @binding(1) var<storage, read_write> blockSums: array<u32>;\r\n\r\noverride WORKGROUP_SIZE_X: u32;\r\noverride WORKGROUP_SIZE_Y: u32;\r\noverride THREADS_PER_WORKGROUP: u32;\r\noverride ITEMS_PER_WORKGROUP: u32;\r\n\r\nconst NUM_BANKS: u32 = 32;\r\nconst LOG_NUM_BANKS: u32 = 5;\r\n\r\nfn get_offset(offset: u32) -> u32 {\r\n    // return offset >> LOG_NUM_BANKS; // Conflict-free\r\n    return (offset >> NUM_BANKS) + (offset >> (2 * LOG_NUM_BANKS)); // Zero bank conflict\r\n}\r\n\r\nvar<workgroup> temp: array<u32, ITEMS_PER_WORKGROUP*2>;\r\n\r\n@compute @workgroup_size(WORKGROUP_SIZE_X, WORKGROUP_SIZE_Y, 1)\r\nfn reduce_downsweep(\r\n    @builtin(workgroup_id) wid: vec3<u32>,\r\n    @builtin(local_invocation_index) TID: u32, // Local thread ID\r\n) {\r\n    let WID = wid.x * THREADS_PER_WORKGROUP;\r\n    let GID = WID + TID; // Global thread ID\r\n    \r\n    let ELM_TID = TID * 2; // Element pair local ID\r\n    let ELM_GID = GID * 2; // Element pair global ID\r\n    \r\n    // Load input to shared memory\r\n    let ai: u32 = TID;\r\n    let bi: u32 = TID + (ITEMS_PER_WORKGROUP >> 1);\r\n    let s_ai = ai + get_offset(ai);\r\n    let s_bi = bi + get_offset(bi);\r\n    let g_ai = ai + WID * 2;\r\n    let g_bi = bi + WID * 2;\r\n    temp[s_ai] = items[g_ai];\r\n    temp[s_bi] = items[g_bi];\r\n\r\n    var offset: u32 = 1;\r\n\r\n    // Up-sweep (reduce) phase\r\n    for (var d: u32 = ITEMS_PER_WORKGROUP >> 1; d > 0; d >>= 1) {\r\n        workgroupBarrier();\r\n\r\n        if (TID < d) {\r\n            var ai: u32 = offset * (ELM_TID + 1) - 1;\r\n            var bi: u32 = offset * (ELM_TID + 2) - 1;\r\n            ai += get_offset(ai);\r\n            bi += get_offset(bi);\r\n            temp[bi] += temp[ai];\r\n        }\r\n\r\n        offset *= 2;\r\n    }\r\n\r\n    // Save workgroup sum and clear last element\r\n    if (TID == 0) {\r\n        var last_offset = ITEMS_PER_WORKGROUP - 1;\r\n        last_offset += get_offset(last_offset);\r\n\r\n        blockSums[wid.x] = temp[last_offset];\r\n        temp[last_offset] = 0;\r\n    }\r\n\r\n    // Down-sweep phase\r\n    for (var d: u32 = 1; d < ITEMS_PER_WORKGROUP; d *= 2) {\r\n        offset >>= 1;\r\n        workgroupBarrier();\r\n\r\n        if (TID < d) {\r\n            var ai: u32 = offset * (ELM_TID + 1) - 1;\r\n            var bi: u32 = offset * (ELM_TID + 2) - 1;\r\n            ai += get_offset(ai);\r\n            bi += get_offset(bi);\r\n\r\n            let t: u32 = temp[ai];\r\n            temp[ai] = temp[bi];\r\n            temp[bi] += t;\r\n        }\r\n    }\r\n    workgroupBarrier();\r\n\r\n    // Copy result from shared memory to global memory\r\n    items[g_ai] = temp[s_ai];\r\n    items[g_bi] = temp[s_bi];\r\n}\r\n\r\n@compute @workgroup_size(WORKGROUP_SIZE_X, WORKGROUP_SIZE_Y, 1)\r\nfn add_block_sums(\r\n    @builtin(workgroup_id) wid: vec3<u32>,\r\n    @builtin(local_invocation_index) TID: u32, // Local thread ID\r\n) {\r\n    let GID = wid.x * THREADS_PER_WORKGROUP + TID; // Global thread ID\r\n\r\n    let ELM_ID = GID * 2;\r\n    let blockSum = blockSums[wid.x];\r\n\r\n    items[ELM_ID] += blockSum;\r\n    items[ELM_ID + 1] += blockSum;\r\n}`\r\n\r\nexport default prefixSumNoBankConflictSource","const radixSortReorderSource = /* wgsl */ `\r\n\r\n@group(0) @binding(0) var<storage, read> inputKeys: array<u32>;\r\n@group(0) @binding(1) var<storage, read_write> outputKeys: array<u32>;\r\n@group(0) @binding(2) var<storage, read> local_prefix_sum: array<u32>;\r\n@group(0) @binding(3) var<storage, read> prefix_block_sum: array<u32>;\r\n@group(0) @binding(4) var<storage, read> inputValues: array<u32>;\r\n@group(0) @binding(5) var<storage, read_write> outputValues: array<u32>;\r\n\r\noverride WORKGROUP_COUNT: u32;\r\noverride THREADS_PER_WORKGROUP: u32;\r\noverride WORKGROUP_SIZE_X: u32;\r\noverride WORKGROUP_SIZE_Y: u32;\r\noverride CURRENT_BIT: u32;\r\noverride ELEMENT_COUNT: u32;\r\n\r\n@compute @workgroup_size(WORKGROUP_SIZE_X, WORKGROUP_SIZE_Y, 1)\r\nfn radix_sort_reorder(\r\n    @builtin(workgroup_id) wid: vec3<u32>,\r\n    @builtin(local_invocation_index) TID: u32, // Local thread ID\r\n) {\r\n    let GID = TID + wid.x * THREADS_PER_WORKGROUP; // Global thread ID\r\n\r\n    if (GID >= ELEMENT_COUNT) {\r\n        return;\r\n    }\r\n\r\n    let k = inputKeys[GID];\r\n    let v = inputValues[GID];\r\n\r\n    let local_prefix = local_prefix_sum[GID];\r\n\r\n    // Calculate new position\r\n    let extract_bits = (k >> CURRENT_BIT) & 0x3;\r\n    let pid = extract_bits * WORKGROUP_COUNT + wid.x;\r\n    let sorted_position = prefix_block_sum[pid] + local_prefix;\r\n    \r\n    outputKeys[sorted_position] = k;\r\n    outputValues[sorted_position] = v;\r\n}`\r\n\r\nexport default radixSortReorderSource;","import PrefixSumKernel from \"./PrefixSumKernel\"\r\nimport radixSortSource from \"./shaders/radix_sort\"\r\nimport radixSortSource_LocalShuffle from \"./shaders/optimizations/radix_sort_local_shuffle\"\r\nimport reorderSource from \"./shaders/radix_sort_reorder\"\r\n\r\nclass RadixSortKernel {\r\n    /**\r\n     * Perform a parallel radix sort on the GPU given a buffer of keys and (optionnaly) values\r\n     * Note: The buffers are sorted in-place.\r\n     * \r\n     * Based on \"Fast 4-way parallel radix sorting on GPUs\"\r\n     * https://www.sci.utah.edu/~csilva/papers/cgf.pdf]\r\n     * \r\n     * @param {GPUDevice} device\r\n     * @param {GPUBuffer} keys - Buffer containing the keys to sort\r\n     * @param {GPUBuffer} values - (optional) Buffer containing the associated values\r\n     * @param {number} count - Number of elements to sort\r\n     * @param {number} bit_count - Number of bits per element (default: 32)\r\n     * @param {object} workgroup_size - Workgroup size in x and y dimensions. (x * y) must be a power of two\r\n     * @param {boolean} local_shuffle - Enable \"local shuffling\" optimization for the radix sort kernel (default: false)\r\n     * @param {boolean} avoid_bank_conflicts - Enable \"avoiding bank conflicts\" optimization for the prefix sum kernel (default: false)\r\n     */\r\n    constructor({\r\n        device,\r\n        keys,\r\n        values,\r\n        count,\r\n        bit_count = 32,\r\n        workgroup_size = { x: 16, y: 16 },\r\n        local_shuffle = false,\r\n        avoid_bank_conflicts = false,\r\n    } = {}) {\r\n        if (device == null) throw new Error('No device provided')\r\n        if (keys == null) throw new Error('No keys buffer provided')\r\n        if (!Number.isInteger(count) || count <= 0) throw new Error('Invalid count parameter')\r\n        if (!Number.isInteger(bit_count) || bit_count <= 0) throw new Error('Invalid bit_count parameter')\r\n        if (!Number.isInteger(workgroup_size.x) || !Number.isInteger(workgroup_size.y)) throw new Error('Invalid workgroup_size parameter')\r\n\r\n        this.device = device\r\n        this.count = count\r\n        this.bit_count = bit_count\r\n        this.workgroup_size = workgroup_size\r\n        this.local_shuffle = local_shuffle\r\n        this.avoid_bank_conflicts = avoid_bank_conflicts\r\n\r\n        this.threads_per_workgroup = workgroup_size.x * workgroup_size.y\r\n        this.workgroup_count = Math.ceil(count / this.threads_per_workgroup)\r\n        this.prefix_block_workgroup_count = 4 * this.workgroup_count\r\n\r\n        this.has_values = (values != null)\r\n\r\n        this.shaderModules = {}\r\n        this.buffers = {}\r\n        this.pipelines = []\r\n\r\n        // Create shader modules from wgsl code\r\n        this.create_shader_modules()\r\n\r\n        // Create GPU buffers\r\n        this.create_buffers(keys, values)\r\n        \r\n        // Create multi-pass pipelines\r\n        this.create_pipelines()\r\n    }\r\n\r\n    create_shader_modules() {\r\n        // Remove every occurence of \"values\" in the shader code if values buffer is not provided\r\n        const remove_values = (source) => {\r\n            return source.split('\\n')\r\n                         .filter(line => !line.toLowerCase().includes('values'))\r\n                         .join('\\n')\r\n        }\r\n\r\n        const blockSumSource = this.local_shuffle ? radixSortSource_LocalShuffle : radixSortSource\r\n        \r\n        this.shaderModules = {\r\n            blockSum: this.device.createShaderModule({\r\n                label: 'radix-sort-block-sum',\r\n                code: this.has_values ? blockSumSource : remove_values(blockSumSource),\r\n            }),\r\n            reorder: this.device.createShaderModule({\r\n                label: 'radix-sort-reorder',\r\n                code: this.has_values ? reorderSource : remove_values(reorderSource),\r\n            })\r\n        }\r\n    }\r\n\r\n    create_buffers(keys, values) {\r\n        // Keys and values double buffering\r\n        const tmpKeysBuffer = this.device.createBuffer({\r\n            size: this.count * 4,\r\n            usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST\r\n        })\r\n        const tmpValuesBuffer = !this.has_values ? null : this.device.createBuffer({\r\n            size: this.count * 4,\r\n            usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST\r\n        })\r\n\r\n        // Local Prefix Sum buffer (1 element per item)\r\n        const localPrefixSumBuffer = this.device.createBuffer({\r\n            size: this.count * 4,\r\n            usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST\r\n        })\r\n\r\n        // Prefix Block Sum buffer (4 element per workgroup)\r\n        const prefixBlockSumBuffer = this.device.createBuffer({\r\n            size: this.prefix_block_workgroup_count * 4,\r\n            usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST\r\n        })\r\n        \r\n        this.buffers = {\r\n            keys: keys,\r\n            values: values,\r\n            tmpKeys: tmpKeysBuffer,\r\n            tmpValues: tmpValuesBuffer,\r\n            localPrefixSum: localPrefixSumBuffer,\r\n            prefixBlockSum: prefixBlockSumBuffer,\r\n        }\r\n    }\r\n\r\n    // Create radix sort passes for every 2 bits\r\n    create_pipelines() {\r\n        for (let bit = 0; bit < this.bit_count; bit += 2) {\r\n            // Swap buffers every pass\r\n            const even      = (bit % 4 == 0)\r\n            const inKeys    = even ? this.buffers.keys : this.buffers.tmpKeys\r\n            const inValues  = even ? this.buffers.values : this.buffers.tmpValues\r\n            const outKeys   = even ? this.buffers.tmpKeys : this.buffers.keys\r\n            const outValues = even ? this.buffers.tmpValues : this.buffers.values\r\n\r\n            // Compute local prefix sums and block sums\r\n            const blockSumPipeline = this.create_block_sum_pipeline(inKeys, inValues, bit)\r\n\r\n            // Compute block sums prefix sums\r\n            const prefixSumKernel = new PrefixSumKernel({ \r\n                device: this.device,\r\n                data: this.buffers.prefixBlockSum, \r\n                count: this.prefix_block_workgroup_count,\r\n                workgroup_size: this.workgroup_size,\r\n                avoid_bank_conflicts: this.avoid_bank_conflicts,\r\n            })\r\n            \r\n            // Reorder keys and values\r\n            const reorderPipeline = this.create_reorder_pipeline(inKeys, inValues, outKeys, outValues, bit)\r\n\r\n            this.pipelines.push({ blockSumPipeline, prefixSumKernel, reorderPipeline })\r\n        }\r\n    }\r\n\r\n    create_block_sum_pipeline(inKeys, inValues, bit) {\r\n        const bindGroupLayout = this.device.createBindGroupLayout({\r\n            label: 'radix-sort-block-sum',\r\n            entries: [\r\n                {\r\n                    binding: 0,\r\n                    visibility: GPUShaderStage.COMPUTE,\r\n                    buffer: { type: this.local_shuffle ? 'storage' : 'read-only-storage' }\r\n                },\r\n                {\r\n                    binding: 1,\r\n                    visibility: GPUShaderStage.COMPUTE,\r\n                    buffer: { type: 'storage' }\r\n                },\r\n                {\r\n                    binding: 2,\r\n                    visibility: GPUShaderStage.COMPUTE,\r\n                    buffer: { type: 'storage' }\r\n                },\r\n                ...(this.local_shuffle && this.has_values ? [{\r\n                    binding: 3,\r\n                    visibility: GPUShaderStage.COMPUTE,\r\n                    buffer: { type: 'storage' }\r\n                }] : [])\r\n            ]\r\n        })\r\n\r\n        const bindGroup = this.device.createBindGroup({\r\n            layout: bindGroupLayout,\r\n            entries: [\r\n                {\r\n                    binding: 0,\r\n                    resource: { buffer: inKeys }\r\n                },\r\n                {\r\n                    binding: 1,\r\n                    resource: { buffer: this.buffers.localPrefixSum }\r\n                },\r\n                {\r\n                    binding: 2,\r\n                    resource: { buffer: this.buffers.prefixBlockSum }\r\n                },\r\n                // \"Local shuffle\" optimization needs access to the values buffer\r\n                ...(this.local_shuffle && this.has_values ? [{\r\n                    binding: 3,\r\n                    resource: { buffer: inValues }\r\n                }] : [])\r\n            ]\r\n        })\r\n\r\n        const pipelineLayout = this.device.createPipelineLayout({\r\n            bindGroupLayouts: [ bindGroupLayout ]\r\n        })\r\n\r\n        const blockSumPipeline = this.device.createComputePipeline({\r\n            label: 'radix-sort-block-sum',\r\n            layout: pipelineLayout,\r\n            compute: {\r\n                module: this.shaderModules.blockSum,\r\n                entryPoint: 'radix_sort',\r\n                constants: {\r\n                    'WORKGROUP_SIZE_X': this.workgroup_size.x,\r\n                    'WORKGROUP_SIZE_Y': this.workgroup_size.y,\r\n                    'WORKGROUP_COUNT': this.workgroup_count,\r\n                    'THREADS_PER_WORKGROUP': this.threads_per_workgroup,\r\n                    'ELEMENT_COUNT': this.count,\r\n                    'CURRENT_BIT': bit,\r\n                }\r\n            }\r\n        })\r\n\r\n        return {\r\n            pipeline: blockSumPipeline,\r\n            bindGroup\r\n        }\r\n    }\r\n\r\n    create_reorder_pipeline(inKeys, inValues, outKeys, outValues, bit) {\r\n        const bindGroupLayout = this.device.createBindGroupLayout({\r\n            label: 'radix-sort-reorder',\r\n            entries: [\r\n                {\r\n                    binding: 0,\r\n                    visibility: GPUShaderStage.COMPUTE,\r\n                    buffer: { type: 'read-only-storage' }\r\n                },\r\n                {\r\n                    binding: 1,\r\n                    visibility: GPUShaderStage.COMPUTE,\r\n                    buffer: { type: 'storage' }\r\n                },\r\n                {\r\n                    binding: 2,\r\n                    visibility: GPUShaderStage.COMPUTE,\r\n                    buffer: { type: 'read-only-storage' }\r\n                },\r\n                {\r\n                    binding: 3,\r\n                    visibility: GPUShaderStage.COMPUTE,\r\n                    buffer: { type: 'read-only-storage' }\r\n                },\r\n                ...(this.has_values ? [\r\n                    {\r\n                        binding: 4,\r\n                        visibility: GPUShaderStage.COMPUTE,\r\n                        buffer: { type: 'read-only-storage' }\r\n                    },\r\n                    {\r\n                        binding: 5,\r\n                        visibility: GPUShaderStage.COMPUTE,\r\n                        buffer: { type: 'storage' }\r\n                    }\r\n                ] : [])\r\n            ]\r\n        })\r\n\r\n        const bindGroup = this.device.createBindGroup({\r\n            layout: bindGroupLayout,\r\n            entries: [\r\n                {\r\n                    binding: 0,\r\n                    resource: { buffer: inKeys }\r\n                },\r\n                {\r\n                    binding: 1,\r\n                    resource: { buffer: outKeys }\r\n                },\r\n                {\r\n                    binding: 2,\r\n                    resource: { buffer: this.buffers.localPrefixSum }\r\n                },\r\n                {\r\n                    binding: 3,\r\n                    resource: { buffer: this.buffers.prefixBlockSum }\r\n                },\r\n                ...(this.has_values ? [\r\n                    {\r\n                        binding: 4,\r\n                        resource: { buffer: inValues }\r\n                    },\r\n                    {\r\n                        binding: 5,\r\n                        resource: { buffer: outValues }\r\n                    }\r\n                ] : [])\r\n            ]\r\n        })\r\n\r\n        const pipelineLayout = this.device.createPipelineLayout({\r\n            bindGroupLayouts: [ bindGroupLayout ]\r\n        })\r\n\r\n        const reorderPipeline = this.device.createComputePipeline({\r\n            label: 'radix-sort-reorder',\r\n            layout: pipelineLayout,\r\n            compute: {\r\n                module: this.shaderModules.reorder,\r\n                entryPoint: 'radix_sort_reorder',\r\n                constants: {\r\n                    'WORKGROUP_SIZE_X': this.workgroup_size.x,\r\n                    'WORKGROUP_SIZE_Y': this.workgroup_size.y,\r\n                    'WORKGROUP_COUNT': this.workgroup_count,\r\n                    'THREADS_PER_WORKGROUP': this.threads_per_workgroup,\r\n                    'ELEMENT_COUNT': this.count,\r\n                    'CURRENT_BIT': bit,\r\n                }\r\n            }\r\n        })\r\n\r\n        return {\r\n            pipeline: reorderPipeline,\r\n            bindGroup\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Encode all pipelines into the current pass\r\n     * \r\n     * @param {GPUComputePassEncoder} pass \r\n     */\r\n    dispatch(pass) {\r\n        for (const { blockSumPipeline, prefixSumKernel, reorderPipeline } of this.pipelines) {            \r\n            pass.setPipeline(blockSumPipeline.pipeline)\r\n            pass.setBindGroup(0, blockSumPipeline.bindGroup)\r\n            pass.dispatchWorkgroups(this.workgroup_count, 1, 1)\r\n\r\n            prefixSumKernel.dispatch(pass)\r\n\r\n            pass.setPipeline(reorderPipeline.pipeline)\r\n            pass.setBindGroup(0, reorderPipeline.bindGroup)\r\n            pass.dispatchWorkgroups(this.workgroup_count, 1, 1)\r\n        }\r\n    }\r\n}\r\n\r\nexport default RadixSortKernel","/**\r\n * Radix sort with \"local shuffle and coalesced mapping\" optimization\r\n * \r\n * (see Implementation section in README for details)\r\n */\r\nconst radixSortCoalescedSource = /* wgsl */ `\r\n\r\n@group(0) @binding(0) var<storage, read_write> input: array<u32>;\r\n@group(0) @binding(1) var<storage, read_write> local_prefix_sums: array<u32>;\r\n@group(0) @binding(2) var<storage, read_write> block_sums: array<u32>;\r\n@group(0) @binding(3) var<storage, read_write> values: array<u32>;\r\n\r\noverride WORKGROUP_COUNT: u32;\r\noverride THREADS_PER_WORKGROUP: u32;\r\noverride WORKGROUP_SIZE_X: u32;\r\noverride WORKGROUP_SIZE_Y: u32;\r\noverride CURRENT_BIT: u32;\r\noverride ELEMENT_COUNT: u32;\r\n\r\nvar<workgroup> s_prefix_sum: array<u32, 2 * (THREADS_PER_WORKGROUP + 1)>;\r\nvar<workgroup> s_prefix_sum_scan: array<u32, 4>;\r\n\r\n@compute @workgroup_size(WORKGROUP_SIZE_X, WORKGROUP_SIZE_Y, 1)\r\nfn radix_sort(\r\n    @builtin(workgroup_id) wid: vec3<u32>,\r\n    @builtin(local_invocation_index) TID: u32, // Local thread ID\r\n) {\r\n    let WID = wid.x * THREADS_PER_WORKGROUP;\r\n    let GID = WID + TID; // Global thread ID\r\n\r\n    // Extract 2 bits from the input\r\n    let elm = input[GID];\r\n    let val = values[GID];\r\n    let extract_bits: u32 = (elm >> CURRENT_BIT) & 0x3;\r\n\r\n    var bit_prefix_sums = array<u32, 4>(0, 0, 0, 0);\r\n\r\n    let LAST_THREAD = min(THREADS_PER_WORKGROUP, ELEMENT_COUNT - WID) - 1;\r\n\r\n    // Initialize parameters for double-buffering\r\n    let TPW = THREADS_PER_WORKGROUP + 1;\r\n    var swapOffset: u32 = 0;\r\n    var inOffset:  u32 = TID;\r\n    var outOffset: u32 = TID + TPW;\r\n\r\n    // 4-way prefix sum\r\n    for (var b: u32 = 0; b < 4; b++) {\r\n        // Initialize local prefix with bitmask\r\n        let bitmask = select(0u, 1u, extract_bits == b);\r\n        s_prefix_sum[inOffset + 1] = bitmask;\r\n        workgroupBarrier();\r\n\r\n        // Prefix sum\r\n        for (var offset: u32 = 1; offset < THREADS_PER_WORKGROUP; offset *= 2) {\r\n            if (TID >= offset) {\r\n                s_prefix_sum[outOffset] = s_prefix_sum[inOffset] + s_prefix_sum[inOffset - offset];\r\n            } else {\r\n                s_prefix_sum[outOffset] = s_prefix_sum[inOffset];\r\n            }\r\n\r\n            // Swap buffers\r\n            outOffset = inOffset;\r\n            swapOffset = TPW - swapOffset;\r\n            inOffset = TID + swapOffset;\r\n            \r\n            workgroupBarrier();\r\n        }\r\n\r\n        // Store prefix sum for current bit\r\n        let prefix_sum = s_prefix_sum[inOffset];\r\n        bit_prefix_sums[b] = prefix_sum;\r\n\r\n        if (TID == LAST_THREAD) {\r\n            // Store block sum to global memory\r\n            let total_sum: u32 = prefix_sum + bitmask;\r\n            block_sums[b * WORKGROUP_COUNT + wid.x] = total_sum;\r\n        }\r\n\r\n        // Swap buffers\r\n        outOffset = inOffset;\r\n        swapOffset = TPW - swapOffset;\r\n        inOffset = TID + swapOffset;\r\n    }\r\n\r\n    let prefix_sum = bit_prefix_sums[extract_bits];   \r\n\r\n    // Scan bit prefix sums\r\n    if (TID == LAST_THREAD) {\r\n        var sum: u32 = 0;\r\n        bit_prefix_sums[extract_bits] += 1;\r\n        for (var i: u32 = 0; i < 4; i++) {\r\n            s_prefix_sum_scan[i] = sum;\r\n            sum += bit_prefix_sums[i];\r\n        }\r\n    }\r\n    workgroupBarrier();\r\n\r\n    if (GID < ELEMENT_COUNT) {\r\n        // Compute new position\r\n        let new_pos: u32 = prefix_sum + s_prefix_sum_scan[extract_bits];\r\n\r\n        // Shuffle elements locally\r\n        input[WID + new_pos] = elm;\r\n        values[WID + new_pos] = val;\r\n        local_prefix_sums[WID + new_pos] = prefix_sum;\r\n    }\r\n}`\r\n\r\nexport default radixSortCoalescedSource;","const radixSortSource = /* wgsl */ `\r\n\r\n@group(0) @binding(0) var<storage, read> input: array<u32>;\r\n@group(0) @binding(1) var<storage, read_write> local_prefix_sums: array<u32>;\r\n@group(0) @binding(2) var<storage, read_write> block_sums: array<u32>;\r\n\r\noverride WORKGROUP_COUNT: u32;\r\noverride THREADS_PER_WORKGROUP: u32;\r\noverride WORKGROUP_SIZE_X: u32;\r\noverride WORKGROUP_SIZE_Y: u32;\r\noverride CURRENT_BIT: u32;\r\noverride ELEMENT_COUNT: u32;\r\n\r\nvar<workgroup> s_prefix_sum: array<u32, 2 * (THREADS_PER_WORKGROUP + 1)>;\r\n\r\n@compute @workgroup_size(WORKGROUP_SIZE_X, WORKGROUP_SIZE_Y, 1)\r\nfn radix_sort(\r\n    @builtin(workgroup_id) wid: vec3<u32>,\r\n    @builtin(local_invocation_index) TID: u32, // Local thread ID\r\n) {\r\n    let WID = wid.x * THREADS_PER_WORKGROUP;\r\n    let GID = WID + TID; // Global thread ID\r\n\r\n    // Extract 2 bits from the input\r\n    let elm = input[GID];\r\n    let extract_bits: u32 = (elm >> CURRENT_BIT) & 0x3;\r\n\r\n    var bit_prefix_sums = array<u32, 4>(0, 0, 0, 0);\r\n\r\n    let LAST_THREAD = min(THREADS_PER_WORKGROUP, ELEMENT_COUNT - WID) - 1;\r\n\r\n    // Initialize parameters for double-buffering\r\n    let TPW = THREADS_PER_WORKGROUP + 1;\r\n    var swapOffset: u32 = 0;\r\n    var inOffset:  u32 = TID;\r\n    var outOffset: u32 = TID + TPW;\r\n\r\n    // 4-way prefix sum\r\n    for (var b: u32 = 0; b < 4; b++) {\r\n        // Initialize local prefix with bitmask\r\n        let bitmask = select(0u, 1u, extract_bits == b);\r\n        s_prefix_sum[inOffset + 1] = bitmask;\r\n        workgroupBarrier();\r\n\r\n        // Prefix sum\r\n        for (var offset: u32 = 1; offset < THREADS_PER_WORKGROUP; offset *= 2) {\r\n            if (TID >= offset) {\r\n                s_prefix_sum[outOffset] = s_prefix_sum[inOffset] + s_prefix_sum[inOffset - offset];\r\n            } else {\r\n                s_prefix_sum[outOffset] = s_prefix_sum[inOffset];\r\n            }\r\n\r\n            // Swap buffers\r\n            outOffset = inOffset;\r\n            swapOffset = TPW - swapOffset;\r\n            inOffset = TID + swapOffset;\r\n            \r\n            workgroupBarrier();\r\n        }\r\n\r\n        // Store prefix sum for current bit\r\n        let prefix_sum = s_prefix_sum[inOffset];\r\n        bit_prefix_sums[b] = prefix_sum;\r\n\r\n        if (TID == LAST_THREAD) {\r\n            // Store block sum to global memory\r\n            let total_sum: u32 = prefix_sum + bitmask;\r\n            block_sums[b * WORKGROUP_COUNT + wid.x] = total_sum;\r\n        }\r\n\r\n        // Swap buffers\r\n        outOffset = inOffset;\r\n        swapOffset = TPW - swapOffset;\r\n        inOffset = TID + swapOffset;\r\n    }\r\n\r\n    // Store local prefix sum to global memory\r\n    local_prefix_sums[GID] = bit_prefix_sums[extract_bits];\r\n}`\r\n\r\nexport default radixSortSource;"],"names":["PrefixSumKernel","_createClass","_ref","device","data","count","_ref$workgroup_size","workgroup_size","x","y","_ref$avoid_bank_confl","avoid_bank_conflicts","_classCallCheck","this","threads_per_workgroup","items_per_workgroup","Math","log2","Error","concat","pipelines","shaderModule","createShaderModule","label","code","create_pass_recursive","key","value","block_count","ceil","blockSumBuffer","createBuffer","size","usage","GPUBufferUsage","STORAGE","COPY_SRC","COPY_DST","bindGroupLayout","createBindGroupLayout","entries","binding","visibility","GPUShaderStage","COMPUTE","buffer","type","bindGroup","createBindGroup","layout","resource","pipelineLayout","createPipelineLayout","bindGroupLayouts","scanPipeline","createComputePipeline","compute","module","entryPoint","constants","WORKGROUP_SIZE_X","WORKGROUP_SIZE_Y","THREADS_PER_WORKGROUP","ITEMS_PER_WORKGROUP","push","pipeline","blockSumPipeline","pass","_step","_iterator","_createForOfIteratorHelper","s","n","done","_step$value","setPipeline","setBindGroup","dispatchWorkgroups","err","e","f","radixSortReorderSource","RadixSortKernel","arguments","length","undefined","keys","values","_ref$bit_count","bit_count","_ref$local_shuffle","local_shuffle","Number","isInteger","workgroup_count","prefix_block_workgroup_count","has_values","shaderModules","buffers","create_shader_modules","create_buffers","create_pipelines","remove_values","source","split","filter","line","toLowerCase","includes","join","blockSumSource","blockSum","reorder","reorderSource","tmpKeysBuffer","tmpValuesBuffer","localPrefixSumBuffer","prefixBlockSumBuffer","tmpKeys","tmpValues","localPrefixSum","prefixBlockSum","bit","even","inKeys","inValues","outKeys","outValues","create_block_sum_pipeline","prefixSumKernel","reorderPipeline","create_reorder_pipeline","_toConsumableArray","WORKGROUP_COUNT","ELEMENT_COUNT","CURRENT_BIT","dispatch"],"mappings":"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"}