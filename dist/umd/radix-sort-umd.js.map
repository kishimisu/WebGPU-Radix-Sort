{"version":3,"file":"radix-sort-umd.js","sources":["../../src/shaders/prefix_sum.js","../../src/shaders/optimizations/prefix_sum_no_bank_conflict.js","../../src/PrefixSumKernel.js","../../src/shaders/radix_sort.js","../../src/shaders/optimizations/radix_sort_local_shuffle.js","../../src/shaders/radix_sort_reorder.js","../../src/RadixSortKernel.js"],"sourcesContent":["const prefixSumSource = /* wgsl */ `\r\n\r\n@group(0) @binding(0) var<storage, read_write> items: array<u32>;\r\n@group(0) @binding(1) var<storage, read_write> blockSums: array<u32>;\r\n\r\noverride WORKGROUP_SIZE_X: u32;\r\noverride WORKGROUP_SIZE_Y: u32;\r\noverride THREADS_PER_WORKGROUP: u32;\r\noverride ITEMS_PER_WORKGROUP: u32;\r\n\r\nvar<workgroup> temp: array<u32, ITEMS_PER_WORKGROUP*2>;\r\n\r\n@compute @workgroup_size(WORKGROUP_SIZE_X, WORKGROUP_SIZE_Y, 1)\r\nfn reduce_downsweep(\r\n    @builtin(workgroup_id) w_id: vec3<u32>,\r\n    @builtin(num_workgroups) w_dim: vec3<u32>,\r\n    @builtin(local_invocation_index) TID: u32, // Local thread ID\r\n) {\r\n    let WORKGROUP_ID = w_id.x + w_id.y * w_dim.x;\r\n    let WID = WORKGROUP_ID * THREADS_PER_WORKGROUP;\r\n    let GID = WID + TID; // Global thread ID\r\n    \r\n    let ELM_TID = TID * 2; // Element pair local ID\r\n    let ELM_GID = GID * 2; // Element pair global ID\r\n    \r\n    // Load input to shared memory\r\n    temp[ELM_TID]     = items[ELM_GID];\r\n    temp[ELM_TID + 1] = items[ELM_GID + 1];\r\n\r\n    var offset: u32 = 1;\r\n\r\n    // Up-sweep (reduce) phase\r\n    for (var d: u32 = ITEMS_PER_WORKGROUP >> 1; d > 0; d >>= 1) {\r\n        workgroupBarrier();\r\n\r\n        if (TID < d) {\r\n            var ai: u32 = offset * (ELM_TID + 1) - 1;\r\n            var bi: u32 = offset * (ELM_TID + 2) - 1;\r\n            temp[bi] += temp[ai];\r\n        }\r\n\r\n        offset *= 2;\r\n    }\r\n\r\n    // Save workgroup sum and clear last element\r\n    if (TID == 0) {\r\n        let last_offset = ITEMS_PER_WORKGROUP - 1;\r\n\r\n        blockSums[WORKGROUP_ID] = temp[last_offset];\r\n        temp[last_offset] = 0;\r\n    }\r\n\r\n    // Down-sweep phase\r\n    for (var d: u32 = 1; d < ITEMS_PER_WORKGROUP; d *= 2) {\r\n        offset >>= 1;\r\n        workgroupBarrier();\r\n\r\n        if (TID < d) {\r\n            var ai: u32 = offset * (ELM_TID + 1) - 1;\r\n            var bi: u32 = offset * (ELM_TID + 2) - 1;\r\n\r\n            let t: u32 = temp[ai];\r\n            temp[ai] = temp[bi];\r\n            temp[bi] += t;\r\n        }\r\n    }\r\n    workgroupBarrier();\r\n\r\n    // Copy result from shared memory to global memory\r\n    items[ELM_GID]     = temp[ELM_TID];\r\n    items[ELM_GID + 1] = temp[ELM_TID + 1];\r\n}\r\n\r\n@compute @workgroup_size(WORKGROUP_SIZE_X, WORKGROUP_SIZE_Y, 1)\r\nfn add_block_sums(\r\n    @builtin(workgroup_id) w_id: vec3<u32>,\r\n    @builtin(num_workgroups) w_dim: vec3<u32>,\r\n    @builtin(local_invocation_index) TID: u32, // Local thread ID\r\n) {\r\n    let WORKGROUP_ID = w_id.x + w_id.y * w_dim.x;\r\n    let WID = WORKGROUP_ID * THREADS_PER_WORKGROUP;\r\n    let GID = WID + TID; // Global thread ID\r\n    \r\n\r\n    let ELM_ID = GID * 2;\r\n    let blockSum = blockSums[WORKGROUP_ID];\r\n\r\n    items[ELM_ID] += blockSum;\r\n    items[ELM_ID + 1] += blockSum;\r\n}`\r\n\r\nexport default prefixSumSource","/**\r\n * Prefix sum with optimization to avoid bank conflicts\r\n * \r\n * (see Implementation section in README for details)\r\n */\r\nconst prefixSumNoBankConflictSource = /* wgsl */ `\r\n\r\n@group(0) @binding(0) var<storage, read_write> items: array<u32>;\r\n@group(0) @binding(1) var<storage, read_write> blockSums: array<u32>;\r\n\r\noverride WORKGROUP_SIZE_X: u32;\r\noverride WORKGROUP_SIZE_Y: u32;\r\noverride THREADS_PER_WORKGROUP: u32;\r\noverride ITEMS_PER_WORKGROUP: u32;\r\n\r\nconst NUM_BANKS: u32 = 32;\r\nconst LOG_NUM_BANKS: u32 = 5;\r\n\r\nfn get_offset(offset: u32) -> u32 {\r\n    // return offset >> LOG_NUM_BANKS; // Conflict-free\r\n    return (offset >> NUM_BANKS) + (offset >> (2 * LOG_NUM_BANKS)); // Zero bank conflict\r\n}\r\n\r\nvar<workgroup> temp: array<u32, ITEMS_PER_WORKGROUP*2>;\r\n\r\n@compute @workgroup_size(WORKGROUP_SIZE_X, WORKGROUP_SIZE_Y, 1)\r\nfn reduce_downsweep(\r\n    @builtin(workgroup_id) w_id: vec3<u32>,\r\n    @builtin(num_workgroups) w_dim: vec3<u32>,\r\n    @builtin(local_invocation_index) TID: u32, // Local thread ID\r\n) {\r\n    let WORKGROUP_ID = w_id.x + w_id.y * w_dim.x;\r\n    let WID = WORKGROUP_ID * THREADS_PER_WORKGROUP;\r\n    let GID = WID + TID; // Global thread ID\r\n    \r\n    let ELM_TID = TID * 2; // Element pair local ID\r\n    let ELM_GID = GID * 2; // Element pair global ID\r\n    \r\n    // Load input to shared memory\r\n    let ai: u32 = TID;\r\n    let bi: u32 = TID + (ITEMS_PER_WORKGROUP >> 1);\r\n    let s_ai = ai + get_offset(ai);\r\n    let s_bi = bi + get_offset(bi);\r\n    let g_ai = ai + WID * 2;\r\n    let g_bi = bi + WID * 2;\r\n    temp[s_ai] = items[g_ai];\r\n    temp[s_bi] = items[g_bi];\r\n\r\n    var offset: u32 = 1;\r\n\r\n    // Up-sweep (reduce) phase\r\n    for (var d: u32 = ITEMS_PER_WORKGROUP >> 1; d > 0; d >>= 1) {\r\n        workgroupBarrier();\r\n\r\n        if (TID < d) {\r\n            var ai: u32 = offset * (ELM_TID + 1) - 1;\r\n            var bi: u32 = offset * (ELM_TID + 2) - 1;\r\n            ai += get_offset(ai);\r\n            bi += get_offset(bi);\r\n            temp[bi] += temp[ai];\r\n        }\r\n\r\n        offset *= 2;\r\n    }\r\n\r\n    // Save workgroup sum and clear last element\r\n    if (TID == 0) {\r\n        var last_offset = ITEMS_PER_WORKGROUP - 1;\r\n        last_offset += get_offset(last_offset);\r\n\r\n        blockSums[WORKGROUP_ID] = temp[last_offset];\r\n        temp[last_offset] = 0;\r\n    }\r\n\r\n    // Down-sweep phase\r\n    for (var d: u32 = 1; d < ITEMS_PER_WORKGROUP; d *= 2) {\r\n        offset >>= 1;\r\n        workgroupBarrier();\r\n\r\n        if (TID < d) {\r\n            var ai: u32 = offset * (ELM_TID + 1) - 1;\r\n            var bi: u32 = offset * (ELM_TID + 2) - 1;\r\n            ai += get_offset(ai);\r\n            bi += get_offset(bi);\r\n\r\n            let t: u32 = temp[ai];\r\n            temp[ai] = temp[bi];\r\n            temp[bi] += t;\r\n        }\r\n    }\r\n    workgroupBarrier();\r\n\r\n    // Copy result from shared memory to global memory\r\n    items[g_ai] = temp[s_ai];\r\n    items[g_bi] = temp[s_bi];\r\n}\r\n\r\n@compute @workgroup_size(WORKGROUP_SIZE_X, WORKGROUP_SIZE_Y, 1)\r\nfn add_block_sums(\r\n    @builtin(workgroup_id) w_id: vec3<u32>,\r\n    @builtin(num_workgroups) w_dim: vec3<u32>,\r\n    @builtin(local_invocation_index) TID: u32, // Local thread ID\r\n) {\r\n    let WORKGROUP_ID = w_id.x + w_id.y * w_dim.x;\r\n    let WID = WORKGROUP_ID * THREADS_PER_WORKGROUP;\r\n    let GID = WID + TID; // Global thread ID\r\n\r\n    let ELM_ID = GID * 2;\r\n    let blockSum = blockSums[WORKGROUP_ID];\r\n\r\n    items[ELM_ID] += blockSum;\r\n    items[ELM_ID + 1] += blockSum;\r\n}`\r\n\r\nexport default prefixSumNoBankConflictSource","import prefixSumSource from \"./shaders/prefix_sum\"\r\nimport prefixSumSource_NoBankConflict from \"./shaders/optimizations/prefix_sum_no_bank_conflict\"\r\n\r\nclass PrefixSumKernel {\r\n    /**\r\n     * Perform a parallel prefix sum on the given data buffer\r\n     * \r\n     * Based on \"Parallel Prefix Sum (Scan) with CUDA\"\r\n     * https://www.eecs.umich.edu/courses/eecs570/hw/parprefix.pdf\r\n     * \r\n     * @param {GPUDevice} device\r\n     * @param {GPUBuffer} data - Buffer containing the data to process\r\n     * @param {number} count - Max number of elements to process\r\n     * @param {object} workgroup_size - Workgroup size in x and y dimensions. (x * y) must be a power of two\r\n     * @param {boolean} avoid_bank_conflicts - Use the \"Avoid bank conflicts\" optimization from the original publication\r\n     */\r\n    constructor({\r\n        device,\r\n        data,\r\n        count,\r\n        workgroup_size = { x: 16, y: 16 },\r\n        avoid_bank_conflicts = false\r\n    }) {\r\n        this.device = device\r\n        this.workgroup_size = workgroup_size\r\n        this.threads_per_workgroup = workgroup_size.x * workgroup_size.y\r\n        this.items_per_workgroup = 2 * this.threads_per_workgroup // 2 items are processed per thread\r\n\r\n        if (Math.log2(this.threads_per_workgroup) % 1 !== 0) \r\n            throw new Error(`workgroup_size.x * workgroup_size.y must be a power of two. (current: ${this.threads_per_workgroup})`)\r\n\r\n        this.pipelines = []\r\n\r\n        this.shaderModule = this.device.createShaderModule({\r\n            label: 'prefix-sum',\r\n            code: avoid_bank_conflicts ? prefixSumSource_NoBankConflict : prefixSumSource,\r\n        })\r\n\r\n        this.create_pass_recursive(data, count)\r\n    }\r\n\r\n    find_optimal_dispatch_size(item_count) {\r\n        const { maxComputeWorkgroupsPerDimension } = this.device.limits\r\n\r\n        let workgroup_count = Math.ceil(item_count / this.items_per_workgroup)\r\n        let x = workgroup_count\r\n        let y = 1\r\n\r\n        if (workgroup_count > maxComputeWorkgroupsPerDimension) {\r\n            x = Math.floor(Math.sqrt(workgroup_count))\r\n            y = Math.ceil(workgroup_count / x)\r\n            workgroup_count = x * y\r\n        }\r\n\r\n        return { \r\n            workgroup_count,\r\n            dispatchSize: { x, y },\r\n        }\r\n    }\r\n\r\n    create_pass_recursive(data, count) {\r\n        // Find best dispatch x and y dimensions to minimize unused threads\r\n        const { workgroup_count, dispatchSize } = this.find_optimal_dispatch_size(count)\r\n        \r\n        // Create buffer for block sums        \r\n        const blockSumBuffer = this.device.createBuffer({\r\n            size: workgroup_count * 4,\r\n            usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST\r\n        })\r\n\r\n        // Create bind group and pipeline layout\r\n        const bindGroupLayout = this.device.createBindGroupLayout({\r\n            entries: [\r\n                {\r\n                    binding: 0,\r\n                    visibility: GPUShaderStage.COMPUTE,\r\n                    buffer: { type: 'storage' }\r\n                },\r\n                {\r\n                    binding: 1,\r\n                    visibility: GPUShaderStage.COMPUTE,\r\n                    buffer: { type: 'storage' }\r\n                }\r\n            ]\r\n        })\r\n\r\n        const bindGroup = this.device.createBindGroup({\r\n            label: 'prefix-sum-bind-group',\r\n            layout: bindGroupLayout,\r\n            entries: [\r\n                {\r\n                    binding: 0,\r\n                    resource: { buffer: data }\r\n                },\r\n                {\r\n                    binding: 1,\r\n                    resource: { buffer: blockSumBuffer }\r\n                }\r\n            ]\r\n        })\r\n\r\n        const pipelineLayout = this.device.createPipelineLayout({\r\n            bindGroupLayouts: [ bindGroupLayout ]\r\n        })\r\n\r\n        // Per-workgroup (block) prefix sum\r\n        const scanPipeline = this.device.createComputePipeline({\r\n            label: 'prefix-sum-scan-pipeline',\r\n            layout: pipelineLayout,\r\n            compute: {\r\n                module: this.shaderModule,\r\n                entryPoint: 'reduce_downsweep',\r\n                constants: {\r\n                    'WORKGROUP_SIZE_X': this.workgroup_size.x,\r\n                    'WORKGROUP_SIZE_Y': this.workgroup_size.y,\r\n                    'THREADS_PER_WORKGROUP': this.threads_per_workgroup,\r\n                    'ITEMS_PER_WORKGROUP': this.items_per_workgroup\r\n                }\r\n            }\r\n        })\r\n\r\n        this.pipelines.push({ pipeline: scanPipeline, bindGroup, dispatchSize })\r\n\r\n        if (workgroup_count > 1) {\r\n            // Prefix sum on block sums\r\n            this.create_pass_recursive(blockSumBuffer, workgroup_count)\r\n\r\n            // Add block sums to local prefix sums\r\n            const blockSumPipeline = this.device.createComputePipeline({\r\n                label: 'prefix-sum-add-block-pipeline',\r\n                layout: pipelineLayout,\r\n                compute: {\r\n                    module: this.shaderModule,\r\n                    entryPoint: 'add_block_sums',\r\n                    constants: {\r\n                        'WORKGROUP_SIZE_X': this.workgroup_size.x,\r\n                        'WORKGROUP_SIZE_Y': this.workgroup_size.y,\r\n                        'THREADS_PER_WORKGROUP': this.threads_per_workgroup\r\n                    }\r\n                }\r\n            })\r\n\r\n            this.pipelines.push({ pipeline: blockSumPipeline, bindGroup, dispatchSize })\r\n        }\r\n    }\r\n\r\n    dispatch(pass) {\r\n        for (const { pipeline, bindGroup, dispatchSize } of this.pipelines) {\r\n            pass.setPipeline(pipeline)\r\n            pass.setBindGroup(0, bindGroup)\r\n            pass.dispatchWorkgroups(dispatchSize.x, dispatchSize.y, 1)\r\n        }\r\n    }\r\n}\r\n\r\nexport default PrefixSumKernel","const radixSortSource = /* wgsl */ `\r\n\r\n@group(0) @binding(0) var<storage, read> input: array<u32>;\r\n@group(0) @binding(1) var<storage, read_write> local_prefix_sums: array<u32>;\r\n@group(0) @binding(2) var<storage, read_write> block_sums: array<u32>;\r\n\r\noverride WORKGROUP_COUNT: u32;\r\noverride THREADS_PER_WORKGROUP: u32;\r\noverride WORKGROUP_SIZE_X: u32;\r\noverride WORKGROUP_SIZE_Y: u32;\r\noverride CURRENT_BIT: u32;\r\noverride ELEMENT_COUNT: u32;\r\n\r\nvar<workgroup> s_prefix_sum: array<u32, 2 * (THREADS_PER_WORKGROUP + 1)>;\r\n\r\n@compute @workgroup_size(WORKGROUP_SIZE_X, WORKGROUP_SIZE_Y, 1)\r\nfn radix_sort(\r\n    @builtin(workgroup_id) w_id: vec3<u32>,\r\n    @builtin(num_workgroups) w_dim: vec3<u32>,\r\n    @builtin(local_invocation_index) TID: u32, // Local thread ID\r\n) {\r\n    let WORKGROUP_ID = w_id.x + w_id.y * w_dim.x;\r\n    let WID = WORKGROUP_ID * THREADS_PER_WORKGROUP;\r\n    let GID = WID + TID; // Global thread ID\r\n\r\n    // Extract 2 bits from the input\r\n    let elm = input[GID];\r\n    let extract_bits: u32 = (elm >> CURRENT_BIT) & 0x3;\r\n\r\n    var bit_prefix_sums = array<u32, 4>(0, 0, 0, 0);\r\n\r\n    // If the workgroup is inactive, prevent block_sums buffer update\r\n    var LAST_THREAD: u32 = 0xffffffff; \r\n\r\n    if (WORKGROUP_ID < WORKGROUP_COUNT) {\r\n        // Otherwise store the index of the last active thread in the workgroup\r\n        LAST_THREAD = min(THREADS_PER_WORKGROUP, ELEMENT_COUNT - WID) - 1;\r\n    }\r\n\r\n    // Initialize parameters for double-buffering\r\n    let TPW = THREADS_PER_WORKGROUP + 1;\r\n    var swapOffset: u32 = 0;\r\n    var inOffset:  u32 = TID;\r\n    var outOffset: u32 = TID + TPW;\r\n\r\n    // 4-way prefix sum\r\n    for (var b: u32 = 0; b < 4; b++) {\r\n        // Initialize local prefix with bitmask\r\n        let bitmask = select(0u, 1u, extract_bits == b);\r\n        s_prefix_sum[inOffset + 1] = bitmask;\r\n        workgroupBarrier();\r\n\r\n        // Prefix sum\r\n        for (var offset: u32 = 1; offset < THREADS_PER_WORKGROUP; offset *= 2) {\r\n            if (TID >= offset) {\r\n                s_prefix_sum[outOffset] = s_prefix_sum[inOffset] + s_prefix_sum[inOffset - offset];\r\n            } else {\r\n                s_prefix_sum[outOffset] = s_prefix_sum[inOffset];\r\n            }\r\n\r\n            // Swap buffers\r\n            outOffset = inOffset;\r\n            swapOffset = TPW - swapOffset;\r\n            inOffset = TID + swapOffset;\r\n            \r\n            workgroupBarrier();\r\n        }\r\n\r\n        // Store prefix sum for current bit\r\n        let prefix_sum = s_prefix_sum[inOffset];\r\n        bit_prefix_sums[b] = prefix_sum;\r\n\r\n        if (TID == LAST_THREAD) {\r\n            // Store block sum to global memory\r\n            let total_sum: u32 = prefix_sum + bitmask;\r\n            block_sums[b * WORKGROUP_COUNT + WORKGROUP_ID] = total_sum;\r\n        }\r\n\r\n        // Swap buffers\r\n        outOffset = inOffset;\r\n        swapOffset = TPW - swapOffset;\r\n        inOffset = TID + swapOffset;\r\n    }\r\n\r\n    // Store local prefix sum to global memory\r\n    local_prefix_sums[GID] = bit_prefix_sums[extract_bits];\r\n}`\r\n\r\nexport default radixSortSource;","/**\r\n * Radix sort with \"local shuffle and coalesced mapping\" optimization\r\n * \r\n * (see Implementation section in README for details)\r\n */\r\nconst radixSortCoalescedSource = /* wgsl */ `\r\n\r\n@group(0) @binding(0) var<storage, read_write> input: array<u32>;\r\n@group(0) @binding(1) var<storage, read_write> local_prefix_sums: array<u32>;\r\n@group(0) @binding(2) var<storage, read_write> block_sums: array<u32>;\r\n@group(0) @binding(3) var<storage, read_write> values: array<u32>;\r\n\r\noverride WORKGROUP_COUNT: u32;\r\noverride THREADS_PER_WORKGROUP: u32;\r\noverride WORKGROUP_SIZE_X: u32;\r\noverride WORKGROUP_SIZE_Y: u32;\r\noverride CURRENT_BIT: u32;\r\noverride ELEMENT_COUNT: u32;\r\n\r\nvar<workgroup> s_prefix_sum: array<u32, 2 * (THREADS_PER_WORKGROUP + 1)>;\r\nvar<workgroup> s_prefix_sum_scan: array<u32, 4>;\r\n\r\n@compute @workgroup_size(WORKGROUP_SIZE_X, WORKGROUP_SIZE_Y, 1)\r\nfn radix_sort(\r\n    @builtin(workgroup_id) w_id: vec3<u32>,\r\n    @builtin(num_workgroups) w_dim: vec3<u32>,\r\n    @builtin(local_invocation_index) TID: u32, // Local thread ID\r\n) {\r\n    let WORKGROUP_ID = w_id.x + w_id.y * w_dim.x;\r\n    let WID = WORKGROUP_ID * THREADS_PER_WORKGROUP;\r\n    let GID = WID + TID; // Global thread ID\r\n\r\n    // Extract 2 bits from the input\r\n    let elm = input[GID];\r\n    let val = values[GID];\r\n    let extract_bits: u32 = (elm >> CURRENT_BIT) & 0x3;\r\n\r\n    var bit_prefix_sums = array<u32, 4>(0, 0, 0, 0);\r\n\r\n    // If the workgroup is inactive, prevent block_sums buffer update\r\n    var LAST_THREAD: u32 = 0xffffffff; \r\n\r\n    if (WORKGROUP_ID < WORKGROUP_COUNT) {\r\n        // Otherwise store the index of the last active thread in the workgroup\r\n        LAST_THREAD = min(THREADS_PER_WORKGROUP, ELEMENT_COUNT - WID) - 1;\r\n    }\r\n\r\n    // Initialize parameters for double-buffering\r\n    let TPW = THREADS_PER_WORKGROUP + 1;\r\n    var swapOffset: u32 = 0;\r\n    var inOffset:  u32 = TID;\r\n    var outOffset: u32 = TID + TPW;\r\n\r\n    // 4-way prefix sum\r\n    for (var b: u32 = 0; b < 4; b++) {\r\n        // Initialize local prefix with bitmask\r\n        let bitmask = select(0u, 1u, extract_bits == b);\r\n        s_prefix_sum[inOffset + 1] = bitmask;\r\n        workgroupBarrier();\r\n\r\n        // Prefix sum\r\n        for (var offset: u32 = 1; offset < THREADS_PER_WORKGROUP; offset *= 2) {\r\n            if (TID >= offset) {\r\n                s_prefix_sum[outOffset] = s_prefix_sum[inOffset] + s_prefix_sum[inOffset - offset];\r\n            } else {\r\n                s_prefix_sum[outOffset] = s_prefix_sum[inOffset];\r\n            }\r\n\r\n            // Swap buffers\r\n            outOffset = inOffset;\r\n            swapOffset = TPW - swapOffset;\r\n            inOffset = TID + swapOffset;\r\n            \r\n            workgroupBarrier();\r\n        }\r\n\r\n        // Store prefix sum for current bit\r\n        let prefix_sum = s_prefix_sum[inOffset];\r\n        bit_prefix_sums[b] = prefix_sum;\r\n\r\n        if (TID == LAST_THREAD) {\r\n            // Store block sum to global memory\r\n            let total_sum: u32 = prefix_sum + bitmask;\r\n            block_sums[b * WORKGROUP_COUNT + WORKGROUP_ID] = total_sum;\r\n        }\r\n\r\n        // Swap buffers\r\n        outOffset = inOffset;\r\n        swapOffset = TPW - swapOffset;\r\n        inOffset = TID + swapOffset;\r\n    }\r\n\r\n    let prefix_sum = bit_prefix_sums[extract_bits];   \r\n\r\n    // Scan bit prefix sums\r\n    if (TID == LAST_THREAD) {\r\n        var sum: u32 = 0;\r\n        bit_prefix_sums[extract_bits] += 1;\r\n        for (var i: u32 = 0; i < 4; i++) {\r\n            s_prefix_sum_scan[i] = sum;\r\n            sum += bit_prefix_sums[i];\r\n        }\r\n    }\r\n    workgroupBarrier();\r\n\r\n    if (GID < ELEMENT_COUNT) {\r\n        // Compute new position\r\n        let new_pos: u32 = prefix_sum + s_prefix_sum_scan[extract_bits];\r\n\r\n        // Shuffle elements locally\r\n        input[WID + new_pos] = elm;\r\n        values[WID + new_pos] = val;\r\n        local_prefix_sums[WID + new_pos] = prefix_sum;\r\n    }\r\n}`\r\n\r\nexport default radixSortCoalescedSource;","const radixSortReorderSource = /* wgsl */ `\r\n\r\n@group(0) @binding(0) var<storage, read> inputKeys: array<u32>;\r\n@group(0) @binding(1) var<storage, read_write> outputKeys: array<u32>;\r\n@group(0) @binding(2) var<storage, read> local_prefix_sum: array<u32>;\r\n@group(0) @binding(3) var<storage, read> prefix_block_sum: array<u32>;\r\n@group(0) @binding(4) var<storage, read> inputValues: array<u32>;\r\n@group(0) @binding(5) var<storage, read_write> outputValues: array<u32>;\r\n\r\noverride WORKGROUP_COUNT: u32;\r\noverride THREADS_PER_WORKGROUP: u32;\r\noverride WORKGROUP_SIZE_X: u32;\r\noverride WORKGROUP_SIZE_Y: u32;\r\noverride CURRENT_BIT: u32;\r\noverride ELEMENT_COUNT: u32;\r\n\r\n@compute @workgroup_size(WORKGROUP_SIZE_X, WORKGROUP_SIZE_Y, 1)\r\nfn radix_sort_reorder(\r\n    @builtin(workgroup_id) w_id: vec3<u32>,\r\n    @builtin(num_workgroups) w_dim: vec3<u32>,\r\n    @builtin(local_invocation_index) TID: u32, // Local thread ID\r\n) { \r\n    let WORKGROUP_ID = w_id.x + w_id.y * w_dim.x;\r\n    let WID = WORKGROUP_ID * THREADS_PER_WORKGROUP;\r\n    let GID = WID + TID; // Global thread ID\r\n\r\n    if (GID >= ELEMENT_COUNT) {\r\n        return;\r\n    }\r\n\r\n    let k = inputKeys[GID];\r\n    let v = inputValues[GID];\r\n\r\n    let local_prefix = local_prefix_sum[GID];\r\n\r\n    // Calculate new position\r\n    let extract_bits = (k >> CURRENT_BIT) & 0x3;\r\n    let pid = extract_bits * WORKGROUP_COUNT + WORKGROUP_ID;\r\n    let sorted_position = prefix_block_sum[pid] + local_prefix;\r\n    \r\n    outputKeys[sorted_position] = k;\r\n    outputValues[sorted_position] = v;\r\n}`\r\n\r\nexport default radixSortReorderSource;","import PrefixSumKernel from \"./PrefixSumKernel\"\r\nimport radixSortSource from \"./shaders/radix_sort\"\r\nimport radixSortSource_LocalShuffle from \"./shaders/optimizations/radix_sort_local_shuffle\"\r\nimport reorderSource from \"./shaders/radix_sort_reorder\"\r\n\r\nclass RadixSortKernel {\r\n    /**\r\n     * Perform a parallel radix sort on the GPU given a buffer of keys and (optionnaly) values\r\n     * Note: The buffers are sorted in-place.\r\n     * \r\n     * Based on \"Fast 4-way parallel radix sorting on GPUs\"\r\n     * https://www.sci.utah.edu/~csilva/papers/cgf.pdf]\r\n     * \r\n     * @param {GPUDevice} device\r\n     * @param {GPUBuffer} keys - Buffer containing the keys to sort\r\n     * @param {GPUBuffer} values - (optional) Buffer containing the associated values\r\n     * @param {number} count - Number of elements to sort\r\n     * @param {number} bit_count - Number of bits per element (default: 32)\r\n     * @param {object} workgroup_size - Workgroup size in x and y dimensions. (x * y) must be a power of two\r\n     * @param {boolean} local_shuffle - Enable \"local shuffling\" optimization for the radix sort kernel (default: false)\r\n     * @param {boolean} avoid_bank_conflicts - Enable \"avoiding bank conflicts\" optimization for the prefix sum kernel (default: false)\r\n     */\r\n    constructor({\r\n        device,\r\n        keys,\r\n        values,\r\n        count,\r\n        bit_count = 32,\r\n        workgroup_size = { x: 16, y: 16 },\r\n        local_shuffle = false,\r\n        avoid_bank_conflicts = false,\r\n    } = {}) {\r\n        if (device == null) throw new Error('No device provided')\r\n        if (keys == null) throw new Error('No keys buffer provided')\r\n        if (!Number.isInteger(count) || count <= 0) throw new Error('Invalid count parameter')\r\n        if (!Number.isInteger(bit_count) || bit_count <= 0) throw new Error('Invalid bit_count parameter')\r\n        if (!Number.isInteger(workgroup_size.x) || !Number.isInteger(workgroup_size.y)) throw new Error('Invalid workgroup_size parameter')\r\n\r\n        this.device = device\r\n        this.count = count\r\n        this.bit_count = bit_count\r\n        this.workgroup_size = workgroup_size\r\n        this.local_shuffle = local_shuffle\r\n        this.avoid_bank_conflicts = avoid_bank_conflicts\r\n\r\n        this.threads_per_workgroup = workgroup_size.x * workgroup_size.y\r\n        this.workgroup_count = Math.ceil(count / this.threads_per_workgroup)\r\n        this.prefix_block_workgroup_count = 4 * this.workgroup_count\r\n\r\n        this.has_values = (values != null) // Is the values buffer provided ?\r\n\r\n        this.dispatchSize = {}  // Dispatch dimension x and y\r\n        this.shaderModules = {} // GPUShaderModules\r\n        this.buffers = {}       // GPUBuffers\r\n        this.pipelines = []     // List of passes\r\n\r\n        // Find best dispatch x and y dimensions to minimize unused threads\r\n        this.find_optimal_dispatch_size()\r\n\r\n        // Create shader modules from wgsl code\r\n        this.create_shader_modules()\r\n\r\n        // Create GPU buffers\r\n        this.create_buffers(keys, values)\r\n        \r\n        // Create multi-pass pipelines\r\n        this.create_pipelines()\r\n    }\r\n\r\n    find_optimal_dispatch_size() {\r\n        const { maxComputeWorkgroupsPerDimension } = this.device.limits\r\n\r\n        this.dispatchSize = { \r\n            x: this.workgroup_count, \r\n            y: 1\r\n        }\r\n\r\n        if (this.workgroup_count > maxComputeWorkgroupsPerDimension) {\r\n            const x = Math.floor(Math.sqrt(this.workgroup_count))\r\n            const y = Math.ceil(this.workgroup_count / x)\r\n            \r\n            this.dispatchSize = { x, y }            \r\n        }\r\n    }\r\n\r\n    create_shader_modules() {\r\n        // Remove every occurence of \"values\" in the shader code if values buffer is not provided\r\n        const remove_values = (source) => {\r\n            return source.split('\\n')\r\n                         .filter(line => !line.toLowerCase().includes('values'))\r\n                         .join('\\n')\r\n        }\r\n\r\n        const blockSumSource = this.local_shuffle ? radixSortSource_LocalShuffle : radixSortSource\r\n        \r\n        this.shaderModules = {\r\n            blockSum: this.device.createShaderModule({\r\n                label: 'radix-sort-block-sum',\r\n                code: this.has_values ? blockSumSource : remove_values(blockSumSource),\r\n            }),\r\n            reorder: this.device.createShaderModule({\r\n                label: 'radix-sort-reorder',\r\n                code: this.has_values ? reorderSource : remove_values(reorderSource),\r\n            })\r\n        }\r\n    }\r\n\r\n    create_buffers(keys, values) {\r\n        // Keys and values double buffering\r\n        const tmpKeysBuffer = this.device.createBuffer({\r\n            size: this.count * 4,\r\n            usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST\r\n        })\r\n        const tmpValuesBuffer = !this.has_values ? null : this.device.createBuffer({\r\n            size: this.count * 4,\r\n            usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST\r\n        })\r\n\r\n        // Local Prefix Sum buffer (1 element per item)\r\n        const localPrefixSumBuffer = this.device.createBuffer({\r\n            size: this.count * 4,\r\n            usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST\r\n        })\r\n\r\n        // Prefix Block Sum buffer (4 element per workgroup)\r\n        const prefixBlockSumBuffer = this.device.createBuffer({\r\n            size: this.prefix_block_workgroup_count * 4,\r\n            usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST\r\n        })\r\n        \r\n        this.buffers = {\r\n            keys: keys,\r\n            values: values,\r\n            tmpKeys: tmpKeysBuffer,\r\n            tmpValues: tmpValuesBuffer,\r\n            localPrefixSum: localPrefixSumBuffer,\r\n            prefixBlockSum: prefixBlockSumBuffer,\r\n        }\r\n    }\r\n\r\n    // Create radix sort passes for every 2 bits\r\n    create_pipelines() {\r\n        for (let bit = 0; bit < this.bit_count; bit += 2) {\r\n            // Swap buffers every pass\r\n            const even      = (bit % 4 == 0)\r\n            const inKeys    = even ? this.buffers.keys : this.buffers.tmpKeys\r\n            const inValues  = even ? this.buffers.values : this.buffers.tmpValues\r\n            const outKeys   = even ? this.buffers.tmpKeys : this.buffers.keys\r\n            const outValues = even ? this.buffers.tmpValues : this.buffers.values\r\n\r\n            // Compute local prefix sums and block sums\r\n            const blockSumPipeline = this.create_block_sum_pipeline(inKeys, inValues, bit)\r\n\r\n            // Compute block sums prefix sums\r\n            const prefixSumKernel = new PrefixSumKernel({ \r\n                device: this.device,\r\n                data: this.buffers.prefixBlockSum, \r\n                count: this.prefix_block_workgroup_count,\r\n                workgroup_size: this.workgroup_size,\r\n                avoid_bank_conflicts: this.avoid_bank_conflicts,\r\n            })\r\n            \r\n            // Reorder keys and values\r\n            const reorderPipeline = this.create_reorder_pipeline(inKeys, inValues, outKeys, outValues, bit)\r\n\r\n            this.pipelines.push({ blockSumPipeline, prefixSumKernel, reorderPipeline })\r\n        }\r\n    }\r\n\r\n    create_block_sum_pipeline(inKeys, inValues, bit) {\r\n        const bindGroupLayout = this.device.createBindGroupLayout({\r\n            label: 'radix-sort-block-sum',\r\n            entries: [\r\n                {\r\n                    binding: 0,\r\n                    visibility: GPUShaderStage.COMPUTE,\r\n                    buffer: { type: this.local_shuffle ? 'storage' : 'read-only-storage' }\r\n                },\r\n                {\r\n                    binding: 1,\r\n                    visibility: GPUShaderStage.COMPUTE,\r\n                    buffer: { type: 'storage' }\r\n                },\r\n                {\r\n                    binding: 2,\r\n                    visibility: GPUShaderStage.COMPUTE,\r\n                    buffer: { type: 'storage' }\r\n                },\r\n                ...(this.local_shuffle && this.has_values ? [{\r\n                    binding: 3,\r\n                    visibility: GPUShaderStage.COMPUTE,\r\n                    buffer: { type: 'storage' }\r\n                }] : [])\r\n            ]\r\n        })\r\n\r\n        const bindGroup = this.device.createBindGroup({\r\n            layout: bindGroupLayout,\r\n            entries: [\r\n                {\r\n                    binding: 0,\r\n                    resource: { buffer: inKeys }\r\n                },\r\n                {\r\n                    binding: 1,\r\n                    resource: { buffer: this.buffers.localPrefixSum }\r\n                },\r\n                {\r\n                    binding: 2,\r\n                    resource: { buffer: this.buffers.prefixBlockSum }\r\n                },\r\n                // \"Local shuffle\" optimization needs access to the values buffer\r\n                ...(this.local_shuffle && this.has_values ? [{\r\n                    binding: 3,\r\n                    resource: { buffer: inValues }\r\n                }] : [])\r\n            ]\r\n        })\r\n\r\n        const pipelineLayout = this.device.createPipelineLayout({\r\n            bindGroupLayouts: [ bindGroupLayout ]\r\n        })\r\n\r\n        const blockSumPipeline = this.device.createComputePipeline({\r\n            label: 'radix-sort-block-sum',\r\n            layout: pipelineLayout,\r\n            compute: {\r\n                module: this.shaderModules.blockSum,\r\n                entryPoint: 'radix_sort',\r\n                constants: {\r\n                    'WORKGROUP_SIZE_X': this.workgroup_size.x,\r\n                    'WORKGROUP_SIZE_Y': this.workgroup_size.y,\r\n                    'WORKGROUP_COUNT': this.workgroup_count,\r\n                    'THREADS_PER_WORKGROUP': this.threads_per_workgroup,\r\n                    'ELEMENT_COUNT': this.count,\r\n                    'CURRENT_BIT': bit,\r\n                }\r\n            }\r\n        })\r\n\r\n        return {\r\n            pipeline: blockSumPipeline,\r\n            bindGroup\r\n        }\r\n    }\r\n\r\n    create_reorder_pipeline(inKeys, inValues, outKeys, outValues, bit) {\r\n        const bindGroupLayout = this.device.createBindGroupLayout({\r\n            label: 'radix-sort-reorder',\r\n            entries: [\r\n                {\r\n                    binding: 0,\r\n                    visibility: GPUShaderStage.COMPUTE,\r\n                    buffer: { type: 'read-only-storage' }\r\n                },\r\n                {\r\n                    binding: 1,\r\n                    visibility: GPUShaderStage.COMPUTE,\r\n                    buffer: { type: 'storage' }\r\n                },\r\n                {\r\n                    binding: 2,\r\n                    visibility: GPUShaderStage.COMPUTE,\r\n                    buffer: { type: 'read-only-storage' }\r\n                },\r\n                {\r\n                    binding: 3,\r\n                    visibility: GPUShaderStage.COMPUTE,\r\n                    buffer: { type: 'read-only-storage' }\r\n                },\r\n                ...(this.has_values ? [\r\n                    {\r\n                        binding: 4,\r\n                        visibility: GPUShaderStage.COMPUTE,\r\n                        buffer: { type: 'read-only-storage' }\r\n                    },\r\n                    {\r\n                        binding: 5,\r\n                        visibility: GPUShaderStage.COMPUTE,\r\n                        buffer: { type: 'storage' }\r\n                    }\r\n                ] : [])\r\n            ]\r\n        })\r\n\r\n        const bindGroup = this.device.createBindGroup({\r\n            layout: bindGroupLayout,\r\n            entries: [\r\n                {\r\n                    binding: 0,\r\n                    resource: { buffer: inKeys }\r\n                },\r\n                {\r\n                    binding: 1,\r\n                    resource: { buffer: outKeys }\r\n                },\r\n                {\r\n                    binding: 2,\r\n                    resource: { buffer: this.buffers.localPrefixSum }\r\n                },\r\n                {\r\n                    binding: 3,\r\n                    resource: { buffer: this.buffers.prefixBlockSum }\r\n                },\r\n                ...(this.has_values ? [\r\n                    {\r\n                        binding: 4,\r\n                        resource: { buffer: inValues }\r\n                    },\r\n                    {\r\n                        binding: 5,\r\n                        resource: { buffer: outValues }\r\n                    }\r\n                ] : [])\r\n            ]\r\n        })\r\n\r\n        const pipelineLayout = this.device.createPipelineLayout({\r\n            bindGroupLayouts: [ bindGroupLayout ]\r\n        })\r\n\r\n        const reorderPipeline = this.device.createComputePipeline({\r\n            label: 'radix-sort-reorder',\r\n            layout: pipelineLayout,\r\n            compute: {\r\n                module: this.shaderModules.reorder,\r\n                entryPoint: 'radix_sort_reorder',\r\n                constants: {\r\n                    'WORKGROUP_SIZE_X': this.workgroup_size.x,\r\n                    'WORKGROUP_SIZE_Y': this.workgroup_size.y,\r\n                    'WORKGROUP_COUNT': this.workgroup_count,\r\n                    'THREADS_PER_WORKGROUP': this.threads_per_workgroup,\r\n                    'ELEMENT_COUNT': this.count,\r\n                    'CURRENT_BIT': bit,\r\n                }\r\n            }\r\n        })\r\n\r\n        return {\r\n            pipeline: reorderPipeline,\r\n            bindGroup\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Encode all pipelines into the current pass\r\n     * \r\n     * @param {GPUComputePassEncoder} pass \r\n     */\r\n    dispatch(pass) {\r\n        for (const { blockSumPipeline, prefixSumKernel, reorderPipeline } of this.pipelines) {            \r\n            pass.setPipeline(blockSumPipeline.pipeline)\r\n            pass.setBindGroup(0, blockSumPipeline.bindGroup)\r\n            pass.dispatchWorkgroups(this.dispatchSize.x, this.dispatchSize.y, 1)\r\n\r\n            prefixSumKernel.dispatch(pass)\r\n\r\n            pass.setPipeline(reorderPipeline.pipeline)\r\n            pass.setBindGroup(0, reorderPipeline.bindGroup)\r\n            pass.dispatchWorkgroups(this.dispatchSize.x, this.dispatchSize.y, 1)\r\n        }\r\n    }\r\n}\r\n\r\nexport default RadixSortKernel"],"names":["prefixSumSource","prefixSumNoBankConflictSource","PrefixSumKernel","_ref","device","data","count","_ref$workgroup_size","workgroup_size","x","y","_ref$avoid_bank_confl","avoid_bank_conflicts","_classCallCheck","threads_per_workgroup","items_per_workgroup","Math","log2","Error","concat","pipelines","shaderModule","createShaderModule","label","code","prefixSumSource_NoBankConflict","create_pass_recursive","_createClass","key","value","find_optimal_dispatch_size","item_count","maxComputeWorkgroupsPerDimension","limits","workgroup_count","ceil","floor","sqrt","dispatchSize","_this$find_optimal_di","blockSumBuffer","createBuffer","size","usage","GPUBufferUsage","STORAGE","COPY_SRC","COPY_DST","bindGroupLayout","createBindGroupLayout","entries","binding","visibility","GPUShaderStage","COMPUTE","buffer","type","bindGroup","createBindGroup","layout","resource","pipelineLayout","createPipelineLayout","bindGroupLayouts","scanPipeline","createComputePipeline","compute","module","entryPoint","constants","push","pipeline","blockSumPipeline","dispatch","pass","_iterator","_createForOfIteratorHelper","_step","s","n","done","_step$value","setPipeline","setBindGroup","dispatchWorkgroups","err","e","f","radixSortSource","radixSortCoalescedSource","radixSortReorderSource","RadixSortKernel","arguments","length","undefined","keys","values","_ref$bit_count","bit_count","_ref$local_shuffle","local_shuffle","Number","isInteger","prefix_block_workgroup_count","has_values","shaderModules","buffers","create_shader_modules","create_buffers","create_pipelines","remove_values","source","split","filter","line","toLowerCase","includes","join","blockSumSource","radixSortSource_LocalShuffle","blockSum","reorder","reorderSource","tmpKeysBuffer","tmpValuesBuffer","localPrefixSumBuffer","prefixBlockSumBuffer","tmpKeys","tmpValues","localPrefixSum","prefixBlockSum","bit","even","inKeys","inValues","outKeys","outValues","create_block_sum_pipeline","prefixSumKernel","reorderPipeline","create_reorder_pipeline","_toConsumableArray"],"mappings":"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"}