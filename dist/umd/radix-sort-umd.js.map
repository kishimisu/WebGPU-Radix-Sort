{"version":3,"file":"radix-sort-umd.js","sources":["../../src/shaders/prefix_sum.js","../../src/shaders/optimizations/prefix_sum_no_bank_conflict.js","../../src/utils.js","../../src/PrefixSumKernel.js","../../src/shaders/radix_sort.js","../../src/shaders/optimizations/radix_sort_local_shuffle.js","../../src/shaders/radix_sort_reorder.js","../../src/shaders/check_sort.js","../../src/CheckSortKernel.js","../../src/RadixSortKernel.js"],"sourcesContent":["const prefixSumSource = /* wgsl */ `\r\n\r\n@group(0) @binding(0) var<storage, read_write> items: array<u32>;\r\n@group(0) @binding(1) var<storage, read_write> blockSums: array<u32>;\r\n\r\noverride WORKGROUP_SIZE_X: u32;\r\noverride WORKGROUP_SIZE_Y: u32;\r\noverride THREADS_PER_WORKGROUP: u32;\r\noverride ITEMS_PER_WORKGROUP: u32;\r\n\r\nvar<workgroup> temp: array<u32, ITEMS_PER_WORKGROUP*2>;\r\n\r\n@compute @workgroup_size(WORKGROUP_SIZE_X, WORKGROUP_SIZE_Y, 1)\r\nfn reduce_downsweep(\r\n    @builtin(workgroup_id) w_id: vec3<u32>,\r\n    @builtin(num_workgroups) w_dim: vec3<u32>,\r\n    @builtin(local_invocation_index) TID: u32, // Local thread ID\r\n) {\r\n    let WORKGROUP_ID = w_id.x + w_id.y * w_dim.x;\r\n    let WID = WORKGROUP_ID * THREADS_PER_WORKGROUP;\r\n    let GID = WID + TID; // Global thread ID\r\n    \r\n    let ELM_TID = TID * 2; // Element pair local ID\r\n    let ELM_GID = GID * 2; // Element pair global ID\r\n    \r\n    // Load input to shared memory\r\n    temp[ELM_TID]     = items[ELM_GID];\r\n    temp[ELM_TID + 1] = items[ELM_GID + 1];\r\n\r\n    var offset: u32 = 1;\r\n\r\n    // Up-sweep (reduce) phase\r\n    for (var d: u32 = ITEMS_PER_WORKGROUP >> 1; d > 0; d >>= 1) {\r\n        workgroupBarrier();\r\n\r\n        if (TID < d) {\r\n            var ai: u32 = offset * (ELM_TID + 1) - 1;\r\n            var bi: u32 = offset * (ELM_TID + 2) - 1;\r\n            temp[bi] += temp[ai];\r\n        }\r\n\r\n        offset *= 2;\r\n    }\r\n\r\n    // Save workgroup sum and clear last element\r\n    if (TID == 0) {\r\n        let last_offset = ITEMS_PER_WORKGROUP - 1;\r\n\r\n        blockSums[WORKGROUP_ID] = temp[last_offset];\r\n        temp[last_offset] = 0;\r\n    }\r\n\r\n    // Down-sweep phase\r\n    for (var d: u32 = 1; d < ITEMS_PER_WORKGROUP; d *= 2) {\r\n        offset >>= 1;\r\n        workgroupBarrier();\r\n\r\n        if (TID < d) {\r\n            var ai: u32 = offset * (ELM_TID + 1) - 1;\r\n            var bi: u32 = offset * (ELM_TID + 2) - 1;\r\n\r\n            let t: u32 = temp[ai];\r\n            temp[ai] = temp[bi];\r\n            temp[bi] += t;\r\n        }\r\n    }\r\n    workgroupBarrier();\r\n\r\n    // Copy result from shared memory to global memory\r\n    items[ELM_GID]     = temp[ELM_TID];\r\n    items[ELM_GID + 1] = temp[ELM_TID + 1];\r\n}\r\n\r\n@compute @workgroup_size(WORKGROUP_SIZE_X, WORKGROUP_SIZE_Y, 1)\r\nfn add_block_sums(\r\n    @builtin(workgroup_id) w_id: vec3<u32>,\r\n    @builtin(num_workgroups) w_dim: vec3<u32>,\r\n    @builtin(local_invocation_index) TID: u32, // Local thread ID\r\n) {\r\n    let WORKGROUP_ID = w_id.x + w_id.y * w_dim.x;\r\n    let WID = WORKGROUP_ID * THREADS_PER_WORKGROUP;\r\n    let GID = WID + TID; // Global thread ID\r\n    \r\n\r\n    let ELM_ID = GID * 2;\r\n    let blockSum = blockSums[WORKGROUP_ID];\r\n\r\n    items[ELM_ID] += blockSum;\r\n    items[ELM_ID + 1] += blockSum;\r\n}`\r\n\r\nexport default prefixSumSource","/**\r\n * Prefix sum with optimization to avoid bank conflicts\r\n * \r\n * (see Implementation section in README for details)\r\n */\r\nconst prefixSumNoBankConflictSource = /* wgsl */ `\r\n\r\n@group(0) @binding(0) var<storage, read_write> items: array<u32>;\r\n@group(0) @binding(1) var<storage, read_write> blockSums: array<u32>;\r\n\r\noverride WORKGROUP_SIZE_X: u32;\r\noverride WORKGROUP_SIZE_Y: u32;\r\noverride THREADS_PER_WORKGROUP: u32;\r\noverride ITEMS_PER_WORKGROUP: u32;\r\n\r\nconst NUM_BANKS: u32 = 32;\r\nconst LOG_NUM_BANKS: u32 = 5;\r\n\r\nfn get_offset(offset: u32) -> u32 {\r\n    // return offset >> LOG_NUM_BANKS; // Conflict-free\r\n    return (offset >> NUM_BANKS) + (offset >> (2 * LOG_NUM_BANKS)); // Zero bank conflict\r\n}\r\n\r\nvar<workgroup> temp: array<u32, ITEMS_PER_WORKGROUP*2>;\r\n\r\n@compute @workgroup_size(WORKGROUP_SIZE_X, WORKGROUP_SIZE_Y, 1)\r\nfn reduce_downsweep(\r\n    @builtin(workgroup_id) w_id: vec3<u32>,\r\n    @builtin(num_workgroups) w_dim: vec3<u32>,\r\n    @builtin(local_invocation_index) TID: u32, // Local thread ID\r\n) {\r\n    let WORKGROUP_ID = w_id.x + w_id.y * w_dim.x;\r\n    let WID = WORKGROUP_ID * THREADS_PER_WORKGROUP;\r\n    let GID = WID + TID; // Global thread ID\r\n    \r\n    let ELM_TID = TID * 2; // Element pair local ID\r\n    let ELM_GID = GID * 2; // Element pair global ID\r\n    \r\n    // Load input to shared memory\r\n    let ai: u32 = TID;\r\n    let bi: u32 = TID + (ITEMS_PER_WORKGROUP >> 1);\r\n    let s_ai = ai + get_offset(ai);\r\n    let s_bi = bi + get_offset(bi);\r\n    let g_ai = ai + WID * 2;\r\n    let g_bi = bi + WID * 2;\r\n    temp[s_ai] = items[g_ai];\r\n    temp[s_bi] = items[g_bi];\r\n\r\n    var offset: u32 = 1;\r\n\r\n    // Up-sweep (reduce) phase\r\n    for (var d: u32 = ITEMS_PER_WORKGROUP >> 1; d > 0; d >>= 1) {\r\n        workgroupBarrier();\r\n\r\n        if (TID < d) {\r\n            var ai: u32 = offset * (ELM_TID + 1) - 1;\r\n            var bi: u32 = offset * (ELM_TID + 2) - 1;\r\n            ai += get_offset(ai);\r\n            bi += get_offset(bi);\r\n            temp[bi] += temp[ai];\r\n        }\r\n\r\n        offset *= 2;\r\n    }\r\n\r\n    // Save workgroup sum and clear last element\r\n    if (TID == 0) {\r\n        var last_offset = ITEMS_PER_WORKGROUP - 1;\r\n        last_offset += get_offset(last_offset);\r\n\r\n        blockSums[WORKGROUP_ID] = temp[last_offset];\r\n        temp[last_offset] = 0;\r\n    }\r\n\r\n    // Down-sweep phase\r\n    for (var d: u32 = 1; d < ITEMS_PER_WORKGROUP; d *= 2) {\r\n        offset >>= 1;\r\n        workgroupBarrier();\r\n\r\n        if (TID < d) {\r\n            var ai: u32 = offset * (ELM_TID + 1) - 1;\r\n            var bi: u32 = offset * (ELM_TID + 2) - 1;\r\n            ai += get_offset(ai);\r\n            bi += get_offset(bi);\r\n\r\n            let t: u32 = temp[ai];\r\n            temp[ai] = temp[bi];\r\n            temp[bi] += t;\r\n        }\r\n    }\r\n    workgroupBarrier();\r\n\r\n    // Copy result from shared memory to global memory\r\n    items[g_ai] = temp[s_ai];\r\n    items[g_bi] = temp[s_bi];\r\n}\r\n\r\n@compute @workgroup_size(WORKGROUP_SIZE_X, WORKGROUP_SIZE_Y, 1)\r\nfn add_block_sums(\r\n    @builtin(workgroup_id) w_id: vec3<u32>,\r\n    @builtin(num_workgroups) w_dim: vec3<u32>,\r\n    @builtin(local_invocation_index) TID: u32, // Local thread ID\r\n) {\r\n    let WORKGROUP_ID = w_id.x + w_id.y * w_dim.x;\r\n    let WID = WORKGROUP_ID * THREADS_PER_WORKGROUP;\r\n    let GID = WID + TID; // Global thread ID\r\n\r\n    let ELM_ID = GID * 2;\r\n    let blockSum = blockSums[WORKGROUP_ID];\r\n\r\n    items[ELM_ID] += blockSum;\r\n    items[ELM_ID + 1] += blockSum;\r\n}`\r\n\r\nexport default prefixSumNoBankConflictSource","/**\r\n * Find the best dispatch size x and y dimensions to minimize unused workgroups\r\n * \r\n * @param {GPUDevice} device - The GPU device\r\n * @param {int} workgroup_count - Number of workgroups to dispatch\r\n * @returns \r\n */\r\nfunction find_optimal_dispatch_size(device, workgroup_count) {\r\n    const dispatchSize = { \r\n        x: workgroup_count, \r\n        y: 1\r\n    }\r\n\r\n    if (workgroup_count > device.limits.maxComputeWorkgroupsPerDimension) {\r\n        const x = Math.floor(Math.sqrt(workgroup_count))\r\n        const y = Math.ceil(workgroup_count / x)\r\n        \r\n        dispatchSize.x = x\r\n        dispatchSize.y = y\r\n    }\r\n\r\n    return dispatchSize\r\n}\r\n\r\nfunction create_buffer_from_data({device, label, data, usage = 0}) {\r\n    const dispatchSizes = device.createBuffer({\r\n        label: label,\r\n        usage: usage,\r\n        size: data.length * 4,\r\n        mappedAtCreation: true\r\n    })\r\n\r\n    const dispatchData = new Uint32Array(dispatchSizes.getMappedRange())\r\n    dispatchData.set(data)\r\n    dispatchSizes.unmap()\r\n\r\n    return dispatchSizes\r\n}\r\n\r\nexport {\r\n    find_optimal_dispatch_size,\r\n    create_buffer_from_data,\r\n}","import prefixSumSource from \"./shaders/prefix_sum\"\r\nimport prefixSumSource_NoBankConflict from \"./shaders/optimizations/prefix_sum_no_bank_conflict\"\r\nimport { find_optimal_dispatch_size } from \"./utils\"\r\n\r\nclass PrefixSumKernel {\r\n    /**\r\n     * Perform a parallel prefix sum on the given data buffer\r\n     * \r\n     * Based on \"Parallel Prefix Sum (Scan) with CUDA\"\r\n     * https://www.eecs.umich.edu/courses/eecs570/hw/parprefix.pdf\r\n     * \r\n     * @param {GPUDevice} device\r\n     * @param {GPUBuffer} data - Buffer containing the data to process\r\n     * @param {number} count - Max number of elements to process\r\n     * @param {object} workgroup_size - Workgroup size in x and y dimensions. (x * y) must be a power of two\r\n     * @param {boolean} avoid_bank_conflicts - Use the \"Avoid bank conflicts\" optimization from the original publication\r\n     */\r\n    constructor({\r\n        device,\r\n        data,\r\n        count,\r\n        workgroup_size = { x: 16, y: 16 },\r\n        avoid_bank_conflicts = false\r\n    }) {\r\n        this.device = device\r\n        this.workgroup_size = workgroup_size\r\n        this.threads_per_workgroup = workgroup_size.x * workgroup_size.y\r\n        this.items_per_workgroup = 2 * this.threads_per_workgroup // 2 items are processed per thread\r\n\r\n        if (Math.log2(this.threads_per_workgroup) % 1 !== 0) \r\n            throw new Error(`workgroup_size.x * workgroup_size.y must be a power of two. (current: ${this.threads_per_workgroup})`)\r\n\r\n        this.pipelines = []\r\n\r\n        this.shaderModule = this.device.createShaderModule({\r\n            label: 'prefix-sum',\r\n            code: avoid_bank_conflicts ? prefixSumSource_NoBankConflict : prefixSumSource,\r\n        })\r\n\r\n        this.create_pass_recursive(data, count)\r\n    }\r\n\r\n    create_pass_recursive(data, count) {\r\n        // Find best dispatch x and y dimensions to minimize unused threads\r\n        const workgroup_count = Math.ceil(count / this.items_per_workgroup)\r\n        const dispatchSize = find_optimal_dispatch_size(this.device, workgroup_count)\r\n        \r\n        // Create buffer for block sums        \r\n        const blockSumBuffer = this.device.createBuffer({\r\n            label: 'prefix-sum-block-sum',\r\n            size: workgroup_count * 4,\r\n            usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST\r\n        })\r\n\r\n        // Create bind group and pipeline layout\r\n        const bindGroupLayout = this.device.createBindGroupLayout({\r\n            entries: [\r\n                {\r\n                    binding: 0,\r\n                    visibility: GPUShaderStage.COMPUTE,\r\n                    buffer: { type: 'storage' }\r\n                },\r\n                {\r\n                    binding: 1,\r\n                    visibility: GPUShaderStage.COMPUTE,\r\n                    buffer: { type: 'storage' }\r\n                }\r\n            ]\r\n        })\r\n\r\n        const bindGroup = this.device.createBindGroup({\r\n            label: 'prefix-sum-bind-group',\r\n            layout: bindGroupLayout,\r\n            entries: [\r\n                {\r\n                    binding: 0,\r\n                    resource: { buffer: data }\r\n                },\r\n                {\r\n                    binding: 1,\r\n                    resource: { buffer: blockSumBuffer }\r\n                }\r\n            ]\r\n        })\r\n\r\n        const pipelineLayout = this.device.createPipelineLayout({\r\n            bindGroupLayouts: [ bindGroupLayout ]\r\n        })\r\n\r\n        // Per-workgroup (block) prefix sum\r\n        const scanPipeline = this.device.createComputePipeline({\r\n            label: 'prefix-sum-scan-pipeline',\r\n            layout: pipelineLayout,\r\n            compute: {\r\n                module: this.shaderModule,\r\n                entryPoint: 'reduce_downsweep',\r\n                constants: {\r\n                    'WORKGROUP_SIZE_X': this.workgroup_size.x,\r\n                    'WORKGROUP_SIZE_Y': this.workgroup_size.y,\r\n                    'THREADS_PER_WORKGROUP': this.threads_per_workgroup,\r\n                    'ITEMS_PER_WORKGROUP': this.items_per_workgroup\r\n                }\r\n            }\r\n        })\r\n\r\n        this.pipelines.push({ pipeline: scanPipeline, bindGroup, dispatchSize })\r\n\r\n        if (workgroup_count > 1) {\r\n            // Prefix sum on block sums\r\n            this.create_pass_recursive(blockSumBuffer, workgroup_count)\r\n\r\n            // Add block sums to local prefix sums\r\n            const blockSumPipeline = this.device.createComputePipeline({\r\n                label: 'prefix-sum-add-block-pipeline',\r\n                layout: pipelineLayout,\r\n                compute: {\r\n                    module: this.shaderModule,\r\n                    entryPoint: 'add_block_sums',\r\n                    constants: {\r\n                        'WORKGROUP_SIZE_X': this.workgroup_size.x,\r\n                        'WORKGROUP_SIZE_Y': this.workgroup_size.y,\r\n                        'THREADS_PER_WORKGROUP': this.threads_per_workgroup\r\n                    }\r\n                }\r\n            })\r\n\r\n            this.pipelines.push({ pipeline: blockSumPipeline, bindGroup, dispatchSize })\r\n        }\r\n    }\r\n\r\n    get_dispatch_chain() {\r\n        return this.pipelines.flatMap(p => [ p.dispatchSize.x, p.dispatchSize.y, 1 ])\r\n    }\r\n\r\n    /**\r\n     * Encode the prefix sum pipeline into the current pass.\r\n     * If dispatchSizeBuffer is provided, the dispatch will be indirect (dispatchWorkgroupsIndirect)\r\n     * \r\n     * @param {GPUComputePassEncoder} pass \r\n     * @param {GPUBuffer} dispatchSizeBuffer - (optional) Indirect dispatch buffer\r\n     * @param {int} offset - (optional) Offset in bytes in the dispatch buffer. Default: 0\r\n     */\r\n    dispatch(pass, dispatchSizeBuffer, offset = 0) {\r\n        for (let i = 0; i < this.pipelines.length; i++) {\r\n            const { pipeline, bindGroup, dispatchSize } = this.pipelines[i]\r\n            \r\n            pass.setPipeline(pipeline)\r\n            pass.setBindGroup(0, bindGroup)\r\n\r\n            if (dispatchSizeBuffer == null)\r\n                pass.dispatchWorkgroups(dispatchSize.x, dispatchSize.y, 1)\r\n            else\r\n                pass.dispatchWorkgroupsIndirect(dispatchSizeBuffer, offset + i * 3 * 4)\r\n        }\r\n    }\r\n}\r\n\r\nexport default PrefixSumKernel","const radixSortSource = /* wgsl */ `\r\n\r\n@group(0) @binding(0) var<storage, read> input: array<u32>;\r\n@group(0) @binding(1) var<storage, read_write> local_prefix_sums: array<u32>;\r\n@group(0) @binding(2) var<storage, read_write> block_sums: array<u32>;\r\n\r\noverride WORKGROUP_COUNT: u32;\r\noverride THREADS_PER_WORKGROUP: u32;\r\noverride WORKGROUP_SIZE_X: u32;\r\noverride WORKGROUP_SIZE_Y: u32;\r\noverride CURRENT_BIT: u32;\r\noverride ELEMENT_COUNT: u32;\r\n\r\nvar<workgroup> s_prefix_sum: array<u32, 2 * (THREADS_PER_WORKGROUP + 1)>;\r\n\r\n@compute @workgroup_size(WORKGROUP_SIZE_X, WORKGROUP_SIZE_Y, 1)\r\nfn radix_sort(\r\n    @builtin(workgroup_id) w_id: vec3<u32>,\r\n    @builtin(num_workgroups) w_dim: vec3<u32>,\r\n    @builtin(local_invocation_index) TID: u32, // Local thread ID\r\n) {\r\n    let WORKGROUP_ID = w_id.x + w_id.y * w_dim.x;\r\n    let WID = WORKGROUP_ID * THREADS_PER_WORKGROUP;\r\n    let GID = WID + TID; // Global thread ID\r\n\r\n    // Extract 2 bits from the input\r\n    let elm = input[GID];\r\n    let extract_bits: u32 = (elm >> CURRENT_BIT) & 0x3;\r\n\r\n    var bit_prefix_sums = array<u32, 4>(0, 0, 0, 0);\r\n\r\n    // If the workgroup is inactive, prevent block_sums buffer update\r\n    var LAST_THREAD: u32 = 0xffffffff; \r\n\r\n    if (WORKGROUP_ID < WORKGROUP_COUNT) {\r\n        // Otherwise store the index of the last active thread in the workgroup\r\n        LAST_THREAD = min(THREADS_PER_WORKGROUP, ELEMENT_COUNT - WID) - 1;\r\n    }\r\n\r\n    // Initialize parameters for double-buffering\r\n    let TPW = THREADS_PER_WORKGROUP + 1;\r\n    var swapOffset: u32 = 0;\r\n    var inOffset:  u32 = TID;\r\n    var outOffset: u32 = TID + TPW;\r\n\r\n    // 4-way prefix sum\r\n    for (var b: u32 = 0; b < 4; b++) {\r\n        // Initialize local prefix with bitmask\r\n        let bitmask = select(0u, 1u, extract_bits == b);\r\n        s_prefix_sum[inOffset + 1] = bitmask;\r\n        workgroupBarrier();\r\n\r\n        // Prefix sum\r\n        for (var offset: u32 = 1; offset < THREADS_PER_WORKGROUP; offset *= 2) {\r\n            if (TID >= offset) {\r\n                s_prefix_sum[outOffset] = s_prefix_sum[inOffset] + s_prefix_sum[inOffset - offset];\r\n            } else {\r\n                s_prefix_sum[outOffset] = s_prefix_sum[inOffset];\r\n            }\r\n\r\n            // Swap buffers\r\n            outOffset = inOffset;\r\n            swapOffset = TPW - swapOffset;\r\n            inOffset = TID + swapOffset;\r\n            \r\n            workgroupBarrier();\r\n        }\r\n\r\n        // Store prefix sum for current bit\r\n        let prefix_sum = s_prefix_sum[inOffset];\r\n        bit_prefix_sums[b] = prefix_sum;\r\n\r\n        if (TID == LAST_THREAD) {\r\n            // Store block sum to global memory\r\n            let total_sum: u32 = prefix_sum + bitmask;\r\n            block_sums[b * WORKGROUP_COUNT + WORKGROUP_ID] = total_sum;\r\n        }\r\n\r\n        // Swap buffers\r\n        outOffset = inOffset;\r\n        swapOffset = TPW - swapOffset;\r\n        inOffset = TID + swapOffset;\r\n    }\r\n\r\n    // Store local prefix sum to global memory\r\n    local_prefix_sums[GID] = bit_prefix_sums[extract_bits];\r\n}`\r\n\r\nexport default radixSortSource;","/**\r\n * Radix sort with \"local shuffle and coalesced mapping\" optimization\r\n * \r\n * (see Implementation section in README for details)\r\n */\r\nconst radixSortCoalescedSource = /* wgsl */ `\r\n\r\n@group(0) @binding(0) var<storage, read_write> input: array<u32>;\r\n@group(0) @binding(1) var<storage, read_write> local_prefix_sums: array<u32>;\r\n@group(0) @binding(2) var<storage, read_write> block_sums: array<u32>;\r\n@group(0) @binding(3) var<storage, read_write> values: array<u32>;\r\n\r\noverride WORKGROUP_COUNT: u32;\r\noverride THREADS_PER_WORKGROUP: u32;\r\noverride WORKGROUP_SIZE_X: u32;\r\noverride WORKGROUP_SIZE_Y: u32;\r\noverride CURRENT_BIT: u32;\r\noverride ELEMENT_COUNT: u32;\r\n\r\nvar<workgroup> s_prefix_sum: array<u32, 2 * (THREADS_PER_WORKGROUP + 1)>;\r\nvar<workgroup> s_prefix_sum_scan: array<u32, 4>;\r\n\r\n@compute @workgroup_size(WORKGROUP_SIZE_X, WORKGROUP_SIZE_Y, 1)\r\nfn radix_sort(\r\n    @builtin(workgroup_id) w_id: vec3<u32>,\r\n    @builtin(num_workgroups) w_dim: vec3<u32>,\r\n    @builtin(local_invocation_index) TID: u32, // Local thread ID\r\n) {\r\n    let WORKGROUP_ID = w_id.x + w_id.y * w_dim.x;\r\n    let WID = WORKGROUP_ID * THREADS_PER_WORKGROUP;\r\n    let GID = WID + TID; // Global thread ID\r\n\r\n    // Extract 2 bits from the input\r\n    let elm = input[GID];\r\n    let val = values[GID];\r\n    let extract_bits: u32 = (elm >> CURRENT_BIT) & 0x3;\r\n\r\n    var bit_prefix_sums = array<u32, 4>(0, 0, 0, 0);\r\n\r\n    // If the workgroup is inactive, prevent block_sums buffer update\r\n    var LAST_THREAD: u32 = 0xffffffff; \r\n\r\n    if (WORKGROUP_ID < WORKGROUP_COUNT) {\r\n        // Otherwise store the index of the last active thread in the workgroup\r\n        LAST_THREAD = min(THREADS_PER_WORKGROUP, ELEMENT_COUNT - WID) - 1;\r\n    }\r\n\r\n    // Initialize parameters for double-buffering\r\n    let TPW = THREADS_PER_WORKGROUP + 1;\r\n    var swapOffset: u32 = 0;\r\n    var inOffset:  u32 = TID;\r\n    var outOffset: u32 = TID + TPW;\r\n\r\n    // 4-way prefix sum\r\n    for (var b: u32 = 0; b < 4; b++) {\r\n        // Initialize local prefix with bitmask\r\n        let bitmask = select(0u, 1u, extract_bits == b);\r\n        s_prefix_sum[inOffset + 1] = bitmask;\r\n        workgroupBarrier();\r\n\r\n        // Prefix sum\r\n        for (var offset: u32 = 1; offset < THREADS_PER_WORKGROUP; offset *= 2) {\r\n            if (TID >= offset) {\r\n                s_prefix_sum[outOffset] = s_prefix_sum[inOffset] + s_prefix_sum[inOffset - offset];\r\n            } else {\r\n                s_prefix_sum[outOffset] = s_prefix_sum[inOffset];\r\n            }\r\n\r\n            // Swap buffers\r\n            outOffset = inOffset;\r\n            swapOffset = TPW - swapOffset;\r\n            inOffset = TID + swapOffset;\r\n            \r\n            workgroupBarrier();\r\n        }\r\n\r\n        // Store prefix sum for current bit\r\n        let prefix_sum = s_prefix_sum[inOffset];\r\n        bit_prefix_sums[b] = prefix_sum;\r\n\r\n        if (TID == LAST_THREAD) {\r\n            // Store block sum to global memory\r\n            let total_sum: u32 = prefix_sum + bitmask;\r\n            block_sums[b * WORKGROUP_COUNT + WORKGROUP_ID] = total_sum;\r\n        }\r\n\r\n        // Swap buffers\r\n        outOffset = inOffset;\r\n        swapOffset = TPW - swapOffset;\r\n        inOffset = TID + swapOffset;\r\n    }\r\n\r\n    let prefix_sum = bit_prefix_sums[extract_bits];   \r\n\r\n    // Scan bit prefix sums\r\n    if (TID == LAST_THREAD) {\r\n        var sum: u32 = 0;\r\n        bit_prefix_sums[extract_bits] += 1;\r\n        for (var i: u32 = 0; i < 4; i++) {\r\n            s_prefix_sum_scan[i] = sum;\r\n            sum += bit_prefix_sums[i];\r\n        }\r\n    }\r\n    workgroupBarrier();\r\n\r\n    if (GID < ELEMENT_COUNT) {\r\n        // Compute new position\r\n        let new_pos: u32 = prefix_sum + s_prefix_sum_scan[extract_bits];\r\n\r\n        // Shuffle elements locally\r\n        input[WID + new_pos] = elm;\r\n        values[WID + new_pos] = val;\r\n        local_prefix_sums[WID + new_pos] = prefix_sum;\r\n    }\r\n}`\r\n\r\nexport default radixSortCoalescedSource;","const radixSortReorderSource = /* wgsl */ `\r\n\r\n@group(0) @binding(0) var<storage, read> inputKeys: array<u32>;\r\n@group(0) @binding(1) var<storage, read_write> outputKeys: array<u32>;\r\n@group(0) @binding(2) var<storage, read> local_prefix_sum: array<u32>;\r\n@group(0) @binding(3) var<storage, read> prefix_block_sum: array<u32>;\r\n@group(0) @binding(4) var<storage, read> inputValues: array<u32>;\r\n@group(0) @binding(5) var<storage, read_write> outputValues: array<u32>;\r\n\r\noverride WORKGROUP_COUNT: u32;\r\noverride THREADS_PER_WORKGROUP: u32;\r\noverride WORKGROUP_SIZE_X: u32;\r\noverride WORKGROUP_SIZE_Y: u32;\r\noverride CURRENT_BIT: u32;\r\noverride ELEMENT_COUNT: u32;\r\n\r\n@compute @workgroup_size(WORKGROUP_SIZE_X, WORKGROUP_SIZE_Y, 1)\r\nfn radix_sort_reorder(\r\n    @builtin(workgroup_id) w_id: vec3<u32>,\r\n    @builtin(num_workgroups) w_dim: vec3<u32>,\r\n    @builtin(local_invocation_index) TID: u32, // Local thread ID\r\n) { \r\n    let WORKGROUP_ID = w_id.x + w_id.y * w_dim.x;\r\n    let WID = WORKGROUP_ID * THREADS_PER_WORKGROUP;\r\n    let GID = WID + TID; // Global thread ID\r\n\r\n    if (GID >= ELEMENT_COUNT) {\r\n        return;\r\n    }\r\n\r\n    let k = inputKeys[GID];\r\n    let v = inputValues[GID];\r\n\r\n    let local_prefix = local_prefix_sum[GID];\r\n\r\n    // Calculate new position\r\n    let extract_bits = (k >> CURRENT_BIT) & 0x3;\r\n    let pid = extract_bits * WORKGROUP_COUNT + WORKGROUP_ID;\r\n    let sorted_position = prefix_block_sum[pid] + local_prefix;\r\n    \r\n    outputKeys[sorted_position] = k;\r\n    outputValues[sorted_position] = v;\r\n}`\r\n\r\nexport default radixSortReorderSource;","const checkSortSource = (isFirstPass = false, isLastPass = false, isFullCheck = false) => /* wgsl */ `\r\n\r\n@group(0) @binding(0) var<storage, read> input: array<u32>;\r\n@group(0) @binding(1) var<storage, read_write> output: array<u32>;\r\n@group(0) @binding(2) var<storage, read> original: array<u32>;\r\n@group(0) @binding(3) var<storage, read_write> is_sorted: u32;\r\n\r\noverride WORKGROUP_SIZE_X: u32;\r\noverride WORKGROUP_SIZE_Y: u32;\r\noverride THREADS_PER_WORKGROUP: u32;\r\noverride ELEMENT_COUNT: u32;\r\noverride START_ELEMENT: u32;\r\n\r\nvar<workgroup> s_data: array<u32, THREADS_PER_WORKGROUP>;\r\n\r\n@compute @workgroup_size(WORKGROUP_SIZE_X, WORKGROUP_SIZE_Y, 1)\r\nfn check_sort(\r\n    @builtin(workgroup_id) w_id: vec3<u32>,\r\n    @builtin(num_workgroups) w_dim: vec3<u32>,\r\n    @builtin(local_invocation_index) TID: u32, // Local thread ID\r\n) {\r\n    let WORKGROUP_ID = w_id.x + w_id.y * w_dim.x;\r\n    let WID = WORKGROUP_ID * THREADS_PER_WORKGROUP + START_ELEMENT;\r\n    let GID = TID + WID; // Global thread ID\r\n\r\n    // Load data into shared memory\r\n    ${ isFirstPass ? first_pass_load_data : \"s_data[TID] = select(0u, input[GID], GID < ELEMENT_COUNT);\" }\r\n\r\n    // Perform parallel reduction\r\n    for (var d = 1u; d < THREADS_PER_WORKGROUP; d *= 2u) {      \r\n        workgroupBarrier();  \r\n        if (TID % (2u * d) == 0u) {\r\n            s_data[TID] += s_data[TID + d];\r\n        }\r\n    }\r\n    workgroupBarrier();\r\n\r\n    // Write reduction result\r\n    ${ isLastPass ? last_pass(isFullCheck) : write_reduction_result }\r\n}`\r\n\r\nconst write_reduction_result = /* wgsl */ `\r\n    if (TID == 0) {\r\n        output[WORKGROUP_ID] = s_data[0];\r\n    }\r\n`\r\n\r\nconst first_pass_load_data = /* wgsl */ `\r\n    let LAST_THREAD = min(THREADS_PER_WORKGROUP, ELEMENT_COUNT - WID) - 1;\r\n\r\n    // Load current element into shared memory\r\n    // Also load next element for comparison\r\n    let elm = select(0u, input[GID], GID < ELEMENT_COUNT);\r\n    let next = select(0u, input[GID + 1], GID < ELEMENT_COUNT-1);\r\n    s_data[TID] = elm;\r\n    workgroupBarrier();\r\n\r\n    s_data[TID] = select(0u, 1u, GID < ELEMENT_COUNT-1 && elm > next);\r\n`\r\n\r\nconst last_pass = (isFullCheck) => /* wgsl */ `\r\n    let fullDispatchLength = arrayLength(&output);\r\n    let dispatchIndex = TID * 3;\r\n\r\n    if (dispatchIndex >= fullDispatchLength) {\r\n        return;\r\n    }\r\n\r\n    ${isFullCheck ? last_pass_full : last_pass_fast}\r\n`\r\n\r\nconst last_pass_fast = /* wgsl */ `\r\n    output[dispatchIndex] = select(0, original[dispatchIndex], s_data[0] == 0 && is_sorted == 0u);\r\n`\r\n\r\nconst last_pass_full = /* wgsl */ `\r\n    if (TID == 0 && s_data[0] == 0) {\r\n        is_sorted = 1u;\r\n    }\r\n\r\n    output[dispatchIndex] = select(0, original[dispatchIndex], s_data[0] != 0);\r\n`\r\nexport default checkSortSource","import checkSortSource from \"./shaders/check_sort\"\r\nimport { find_optimal_dispatch_size } from \"./utils\"\r\n\r\nclass CheckSortKernel {\r\n    /**\r\n     * CheckSortKernel - Performs a parralel reduction to check if an array is sorted.\r\n     * \r\n     * @param {GPUDevice} device\r\n     * @param {GPUBuffer} data - The buffer containing the data to check\r\n     * @param {GPUBuffer} result - The result dispatch size buffer\r\n     * @param {GPUBuffer} original - The original dispatch size buffer\r\n     * @param {GPUBuffer} is_sorted - 1-element buffer to store whether the array is sorted\r\n     * @param {number} count - The number of elements to check\r\n     * @param {number} start - The index to start checking from\r\n     * @param {boolean} full_check - Whether this kernel is performing a full check or a fast check\r\n     * @param {object} workgroup_size - The workgroup size in x and y dimensions\r\n     */\r\n    constructor({\r\n        device,\r\n        data,\r\n        result,\r\n        original,\r\n        is_sorted,\r\n        count,\r\n        start = 0,\r\n        full_check = true,\r\n        workgroup_size = { x: 16, y: 16 },\r\n    }) {\r\n        this.device = device\r\n        this.count = count\r\n        this.start = start\r\n        this.full_check = full_check\r\n        this.workgroup_size = workgroup_size\r\n        this.threads_per_workgroup = workgroup_size.x * workgroup_size.y\r\n\r\n        this.pipelines = []\r\n\r\n        this.buffers = {\r\n            data, \r\n            result, \r\n            original, \r\n            is_sorted,\r\n            outputs: []\r\n        }\r\n\r\n        this.create_passes_recursive(data, count)\r\n    }\r\n\r\n    // Find the best dispatch size for each pass to minimize unused workgroups\r\n    static find_optimal_dispatch_chain(device, item_count, workgroup_size) {\r\n        const threads_per_workgroup = workgroup_size.x * workgroup_size.y\r\n        const sizes = []\r\n\r\n        do {\r\n            // Number of workgroups required to process all items\r\n            const target_workgroup_count = Math.ceil(item_count / threads_per_workgroup)\r\n    \r\n            // Optimal dispatch size and updated workgroup count\r\n            const dispatchSize = find_optimal_dispatch_size(device, target_workgroup_count)\r\n    \r\n            sizes.push(dispatchSize.x, dispatchSize.y, 1)\r\n            item_count = target_workgroup_count\r\n        } while (item_count > 1)\r\n    \r\n        return sizes\r\n    }\r\n\r\n    create_passes_recursive(buffer, count, passIndex = 0) {\r\n        const workgroup_count = Math.ceil(count / this.threads_per_workgroup)\r\n\r\n        const isFirstPass = passIndex === 0\r\n        const isLastPass = workgroup_count <= 1\r\n\r\n        const outputBuffer = isLastPass ? this.buffers.result : this.device.createBuffer({\r\n            label: `check-sort-${this.full_check ? 'full' : 'fast'}-${passIndex}`,\r\n            size: workgroup_count * 4,\r\n            usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST\r\n        })\r\n\r\n        const bindGroupLayout = this.device.createBindGroupLayout({\r\n            entries: [\r\n                {\r\n                    binding: 0,\r\n                    visibility: GPUShaderStage.COMPUTE,\r\n                    buffer: { type: 'read-only-storage' }\r\n                },\r\n                {\r\n                    binding: 1,\r\n                    visibility: GPUShaderStage.COMPUTE,\r\n                    buffer: { type: 'storage' }\r\n                },\r\n                // Last pass bindings\r\n                ...(isLastPass ? [{\r\n                    binding: 2,\r\n                    visibility: GPUShaderStage.COMPUTE,\r\n                    buffer: { type: 'read-only-storage' }\r\n                }, {\r\n                    binding: 3,\r\n                    visibility: GPUShaderStage.COMPUTE,\r\n                    buffer: { type: 'storage' }\r\n                }] : []),\r\n            ]\r\n        })\r\n\r\n        const bindGroup = this.device.createBindGroup({\r\n            layout: bindGroupLayout,\r\n            entries: [\r\n                {\r\n                    binding: 0,\r\n                    resource: { buffer: buffer }\r\n                },\r\n                {\r\n                    binding: 1,\r\n                    resource: { buffer: outputBuffer }\r\n                },\r\n                // Last pass buffers\r\n                ...(isLastPass ? [{\r\n                    binding: 2,\r\n                    resource: { buffer: this.buffers.original }\r\n                }, {\r\n                    binding: 3,\r\n                    resource: { buffer: this.buffers.is_sorted }\r\n                }] : []),\r\n            ]\r\n        })\r\n\r\n        const pipelineLayout = this.device.createPipelineLayout({\r\n            bindGroupLayouts: [bindGroupLayout]\r\n        })\r\n\r\n        const element_count = isFirstPass ? this.start + count : count\r\n        const start_element = isFirstPass ? this.start : 0\r\n\r\n        const checkSortPipeline = this.device.createComputePipeline({\r\n            layout: pipelineLayout,\r\n            compute: {\r\n                module: this.device.createShaderModule({\r\n                    code: checkSortSource(isFirstPass, isLastPass, this.full_check),\r\n                    label: 'check-sort',\r\n                }),\r\n                entryPoint: 'check_sort',\r\n                constants: {\r\n                    'WORKGROUP_SIZE_X': this.workgroup_size.x,\r\n                    'WORKGROUP_SIZE_Y': this.workgroup_size.y,\r\n                    'THREADS_PER_WORKGROUP': this.threads_per_workgroup,\r\n                    'ELEMENT_COUNT': element_count,\r\n                    'START_ELEMENT': start_element,\r\n                },\r\n            }\r\n        })\r\n\r\n        this.buffers.outputs.push(outputBuffer)\r\n        this.pipelines.push({ pipeline: checkSortPipeline, bindGroup })\r\n        \r\n        if (!isLastPass) {\r\n            this.create_passes_recursive(outputBuffer, workgroup_count, passIndex + 1)\r\n        }\r\n    }\r\n\r\n    dispatch(pass, dispatchSize, offset = 0) {\r\n        for (let i = 0; i < this.pipelines.length; i++) {\r\n            const { pipeline, bindGroup } = this.pipelines[i]\r\n\r\n            const dispatchIndirect = (this.full_check || i < this.pipelines.length - 1)\r\n\r\n            pass.setPipeline(pipeline)\r\n            pass.setBindGroup(0, bindGroup)\r\n\r\n            if (dispatchIndirect)\r\n                pass.dispatchWorkgroupsIndirect(dispatchSize, offset + i * 3 * 4)\r\n            else\r\n                // Only the last dispatch of the fast check kernel is constant to (1, 1, 1)\r\n                pass.dispatchWorkgroups(1, 1, 1)\r\n        }\r\n    }\r\n}\r\n\r\nexport default CheckSortKernel","import PrefixSumKernel from \"./PrefixSumKernel\"\r\nimport radixSortSource from \"./shaders/radix_sort\"\r\nimport radixSortSource_LocalShuffle from \"./shaders/optimizations/radix_sort_local_shuffle\"\r\nimport reorderSource from \"./shaders/radix_sort_reorder\"\r\nimport CheckSortKernel from \"./CheckSortKernel\"\r\nimport { create_buffer_from_data, find_optimal_dispatch_size } from \"./utils\"\r\n\r\nclass RadixSortKernel {\r\n    /**\r\n     * Perform a parallel radix sort on the GPU given a buffer of keys and (optionnaly) values\r\n     * Note: The buffers are sorted in-place.\r\n     * \r\n     * Based on \"Fast 4-way parallel radix sorting on GPUs\"\r\n     * https://www.sci.utah.edu/~csilva/papers/cgf.pdf]\r\n     * \r\n     * @param {GPUDevice} device\r\n     * @param {GPUBuffer} keys - Buffer containing the keys to sort\r\n     * @param {GPUBuffer} values - (optional) Buffer containing the associated values\r\n     * @param {number} count - Number of elements to sort\r\n     * @param {number} bit_count - Number of bits per element (default: 32)\r\n     * @param {object} workgroup_size - Workgroup size in x and y dimensions. (x * y) must be a power of two\r\n     * @param {boolean} check_order - Enable \"order checking\" optimization. Useful if the data needs to be sorted in real-time and doesn't change much. (default: false)\r\n     * @param {boolean} local_shuffle - Enable \"local shuffling\" optimization for the radix sort kernel (default: false)\r\n     * @param {boolean} avoid_bank_conflicts - Enable \"avoiding bank conflicts\" optimization for the prefix sum kernel (default: false)\r\n     */\r\n    constructor({\r\n        device,\r\n        keys,\r\n        values,\r\n        count,\r\n        bit_count = 32,\r\n        workgroup_size = { x: 16, y: 16 },\r\n        check_order = false,\r\n        local_shuffle = false,\r\n        avoid_bank_conflicts = false,\r\n    } = {}) {\r\n        if (device == null) throw new Error('No device provided')\r\n        if (keys == null) throw new Error('No keys buffer provided')\r\n        if (!Number.isInteger(count) || count <= 0) throw new Error('Invalid count parameter')\r\n        if (!Number.isInteger(bit_count) || bit_count <= 0 || bit_count > 32) throw new Error(`Invalid bit_count parameter: ${bit_count}`)\r\n        if (!Number.isInteger(workgroup_size.x) || !Number.isInteger(workgroup_size.y)) throw new Error('Invalid workgroup_size parameter')\r\n        if (bit_count % 4 != 0) throw new Error('bit_count must be a multiple of 4')\r\n\r\n        this.device = device\r\n        this.count = count\r\n        this.bit_count = bit_count\r\n        this.workgroup_size = workgroup_size\r\n        this.check_order = check_order\r\n        this.local_shuffle = local_shuffle\r\n        this.avoid_bank_conflicts = avoid_bank_conflicts\r\n\r\n        this.threads_per_workgroup = workgroup_size.x * workgroup_size.y\r\n        this.workgroup_count = Math.ceil(count / this.threads_per_workgroup)\r\n        this.prefix_block_workgroup_count = 4 * this.workgroup_count\r\n\r\n        this.has_values = (values != null) // Is the values buffer provided ?\r\n\r\n        this.dispatchSize = {}  // Dispatch dimension x and y\r\n        this.shaderModules = {} // GPUShaderModules\r\n        this.kernels = {}       // PrefixSumKernel & CheckSortKernels\r\n        this.pipelines = []     // List of passes\r\n        this.buffers = {        // GPUBuffers\r\n            keys: keys,\r\n            values: values\r\n        }       \r\n\r\n        // Create shader modules from wgsl code\r\n        this.create_shader_modules()\r\n        \r\n        // Create multi-pass pipelines\r\n        this.create_pipelines()\r\n    }\r\n\r\n    create_shader_modules() {\r\n        // Remove every occurence of \"values\" in the shader code if values buffer is not provided\r\n        const remove_values = (source) => {\r\n            return source.split('\\n')\r\n                         .filter(line => !line.toLowerCase().includes('values'))\r\n                         .join('\\n')\r\n        }\r\n\r\n        const blockSumSource = this.local_shuffle ? radixSortSource_LocalShuffle : radixSortSource\r\n        \r\n        this.shaderModules = {\r\n            blockSum: this.device.createShaderModule({\r\n                label: 'radix-sort-block-sum',\r\n                code: this.has_values ? blockSumSource : remove_values(blockSumSource),\r\n            }),\r\n            reorder: this.device.createShaderModule({\r\n                label: 'radix-sort-reorder',\r\n                code: this.has_values ? reorderSource : remove_values(reorderSource),\r\n            })\r\n        }\r\n    }\r\n\r\n    create_pipelines() {    \r\n        // Block prefix sum kernel    \r\n        this.create_prefix_sum_kernel()\r\n\r\n        // Indirect dispatch buffers\r\n        const dispatchData = this.calculate_dispatch_sizes()\r\n\r\n        // GPU buffers\r\n        this.create_buffers(dispatchData)\r\n\r\n        // Check sort kernels\r\n        this.create_check_sort_kernels(dispatchData)\r\n\r\n        // Radix sort passes for every 2 bits\r\n        for (let bit = 0; bit < this.bit_count; bit += 2) {\r\n            // Swap buffers every pass\r\n            const even      = (bit % 4 == 0)\r\n            const inKeys    = even ? this.buffers.keys : this.buffers.tmpKeys\r\n            const inValues  = even ? this.buffers.values : this.buffers.tmpValues\r\n            const outKeys   = even ? this.buffers.tmpKeys : this.buffers.keys\r\n            const outValues = even ? this.buffers.tmpValues : this.buffers.values\r\n\r\n            // Compute local prefix sums and block sums\r\n            const blockSumPipeline = this.create_block_sum_pipeline(inKeys, inValues, bit)\r\n            \r\n            // Reorder keys and values\r\n            const reorderPipeline = this.create_reorder_pipeline(inKeys, inValues, outKeys, outValues, bit)\r\n\r\n            this.pipelines.push({ blockSumPipeline, reorderPipeline })\r\n        }\r\n    }\r\n\r\n    create_prefix_sum_kernel() {\r\n        // Prefix Block Sum buffer (4 element per workgroup)\r\n        const prefixBlockSumBuffer = this.device.createBuffer({\r\n            label: 'radix-sort-prefix-block-sum',\r\n            size: this.prefix_block_workgroup_count * 4,\r\n            usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST\r\n        })\r\n\r\n        // Create block prefix sum kernel\r\n        const prefixSumKernel = new PrefixSumKernel({ \r\n            device: this.device,\r\n            data: prefixBlockSumBuffer, \r\n            count: this.prefix_block_workgroup_count,\r\n            workgroup_size: this.workgroup_size,\r\n            avoid_bank_conflicts: this.avoid_bank_conflicts,\r\n        })\r\n\r\n        this.kernels.prefixSum = prefixSumKernel\r\n        this.buffers.prefixBlockSum = prefixBlockSumBuffer\r\n    }\r\n\r\n    calculate_dispatch_sizes() {\r\n        // Radix sort dispatch size\r\n        const dispatchSize = find_optimal_dispatch_size(this.device, this.workgroup_count)\r\n\r\n        // Prefix sum dispatch sizes\r\n        const prefixSumDispatchSize = this.kernels.prefixSum.get_dispatch_chain()\r\n\r\n        // Check sort element count (fast/full)\r\n        const check_sort_fast_count = Math.min(this.count, this.threads_per_workgroup * 4)\r\n        const check_sort_full_count = this.count - check_sort_fast_count\r\n        const start_full = check_sort_fast_count - 1\r\n\r\n        // Check sort dispatch sizes\r\n        const dispatchSizesFast = CheckSortKernel.find_optimal_dispatch_chain(this.device, check_sort_fast_count, this.workgroup_size)\r\n        const dispatchSizesFull = CheckSortKernel.find_optimal_dispatch_chain(this.device, check_sort_full_count, this.workgroup_size)\r\n\r\n        // Initial dispatch sizes\r\n        const initialDispatch = [\r\n            dispatchSize.x, dispatchSize.y, 1, // Radix Sort + Reorder\r\n            ...dispatchSizesFast.slice(0, 3),  // Check sort fast\r\n            ...prefixSumDispatchSize           // Prefix Sum\r\n        ]\r\n\r\n        // Dispatch offsets in main buffer\r\n        this.dispatchOffsets = {\r\n            radix_sort: 0,\r\n            check_sort_fast: 3 * 4,\r\n            prefix_sum: 6 * 4\r\n        }\r\n\r\n        this.dispatchSize = dispatchSize\r\n\r\n        return {\r\n            initialDispatch,\r\n            dispatchSizesFull,\r\n            check_sort_fast_count, \r\n            check_sort_full_count, \r\n            start_full \r\n        }\r\n    }\r\n\r\n    create_buffers(dispatchData) {\r\n        // Keys and values double buffering\r\n        const tmpKeysBuffer = this.device.createBuffer({\r\n            label: 'radix-sort-tmp-keys',\r\n            size: this.count * 4,\r\n            usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST\r\n        })\r\n        const tmpValuesBuffer = !this.has_values ? null : this.device.createBuffer({\r\n            label: 'radix-sort-tmp-values',\r\n            size: this.count * 4,\r\n            usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST\r\n        })\r\n\r\n        // Local Prefix Sum buffer (1 element per item)\r\n        const localPrefixSumBuffer = this.device.createBuffer({\r\n            label: 'radix-sort-local-prefix-sum',\r\n            size: this.count * 4,\r\n            usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST\r\n        })\r\n\r\n        this.buffers.tmpKeys = tmpKeysBuffer\r\n        this.buffers.tmpValues = tmpValuesBuffer\r\n        this.buffers.localPrefixSum = localPrefixSumBuffer\r\n\r\n        // Only create indirect dispatch buffers when check_order optimization is enabled\r\n        if (!this.check_order) {\r\n            return\r\n        }\r\n\r\n        // Dispatch sizes (radix sort, check sort, prefix sum)\r\n        const dispatchBuffer = create_buffer_from_data({\r\n            device: this.device, \r\n            label: 'radix-sort-dispatch-size',\r\n            data: dispatchData.initialDispatch, \r\n            usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.INDIRECT\r\n        })\r\n        const originalDispatchBuffer = create_buffer_from_data({\r\n            device: this.device, \r\n            label: 'radix-sort-dispatch-size-original',\r\n            data: dispatchData.initialDispatch, \r\n            usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC\r\n        })\r\n\r\n        // Dispatch sizes (full sort)\r\n        const checkSortFullDispatchBuffer = create_buffer_from_data({\r\n            label: 'check-sort-full-dispatch-size',\r\n            device: this.device, \r\n            data: dispatchData.dispatchSizesFull,\r\n            usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.INDIRECT\r\n        })\r\n        const checkSortFullOriginalDispatchBuffer = create_buffer_from_data({\r\n            label: 'check-sort-full-dispatch-size-original',\r\n            device: this.device, \r\n            data: dispatchData.dispatchSizesFull,\r\n            usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC\r\n        })\r\n\r\n        // Flag to tell if the data is sorted\r\n        const isSortedBuffer = create_buffer_from_data({\r\n            label: 'is-sorted',\r\n            device: this.device, \r\n            data: new Uint32Array([0]), \r\n            usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST\r\n        })\r\n\r\n        this.buffers.dispatchSize = dispatchBuffer\r\n        this.buffers.originalDispatchSize = originalDispatchBuffer\r\n        this.buffers.checkSortFullDispatchSize = checkSortFullDispatchBuffer\r\n        this.buffers.originalCheckSortFullDispatchSize = checkSortFullOriginalDispatchBuffer\r\n        this.buffers.isSorted = isSortedBuffer\r\n    }\r\n\r\n    create_check_sort_kernels(checkSortPartitionData) {\r\n        if (!this.check_order) {\r\n            return\r\n        }\r\n\r\n        const { check_sort_fast_count, check_sort_full_count, start_full } = checkSortPartitionData\r\n\r\n        // Create the full pass\r\n        const checkSortFull = new CheckSortKernel({\r\n            device: this.device,\r\n            data: this.buffers.keys,\r\n            result: this.buffers.dispatchSize,\r\n            original: this.buffers.originalDispatchSize,\r\n            is_sorted: this.buffers.isSorted,\r\n            count: check_sort_full_count,\r\n            start: start_full,\r\n            full_check: true,\r\n            workgroup_size: this.workgroup_size\r\n        })\r\n\r\n        // Create the fast pass\r\n        const checkSortFast = new CheckSortKernel({\r\n            device: this.device,\r\n            data: this.buffers.keys,\r\n            result: this.buffers.checkSortFullDispatchSize,\r\n            original: this.buffers.originalCheckSortFullDispatchSize,\r\n            is_sorted: this.buffers.isSorted,\r\n            count: check_sort_fast_count,\r\n            full_check: false,\r\n            workgroup_size: this.workgroup_size\r\n        })\r\n\r\n        if (checkSortFast.threads_per_workgroup < checkSortFull.pipelines.length) {\r\n            console.warn(`Warning: workgroup size is too small to enable check sort optimization, disabling...`)\r\n            this.check_order = false\r\n            return\r\n        }\r\n\r\n        this.kernels.checkSortFast = checkSortFast\r\n        this.kernels.checkSortFull = checkSortFull\r\n    }\r\n\r\n    create_block_sum_pipeline(inKeys, inValues, bit) {\r\n        const bindGroupLayout = this.device.createBindGroupLayout({\r\n            label: 'radix-sort-block-sum',\r\n            entries: [\r\n                {\r\n                    binding: 0,\r\n                    visibility: GPUShaderStage.COMPUTE,\r\n                    buffer: { type: this.local_shuffle ? 'storage' : 'read-only-storage' }\r\n                },\r\n                {\r\n                    binding: 1,\r\n                    visibility: GPUShaderStage.COMPUTE,\r\n                    buffer: { type: 'storage' }\r\n                },\r\n                {\r\n                    binding: 2,\r\n                    visibility: GPUShaderStage.COMPUTE,\r\n                    buffer: { type: 'storage' }\r\n                },\r\n                ...(this.local_shuffle && this.has_values ? [{\r\n                    binding: 3,\r\n                    visibility: GPUShaderStage.COMPUTE,\r\n                    buffer: { type: 'storage' }\r\n                }] : [])\r\n            ]\r\n        })\r\n\r\n        const bindGroup = this.device.createBindGroup({\r\n            layout: bindGroupLayout,\r\n            entries: [\r\n                {\r\n                    binding: 0,\r\n                    resource: { buffer: inKeys }\r\n                },\r\n                {\r\n                    binding: 1,\r\n                    resource: { buffer: this.buffers.localPrefixSum }\r\n                },\r\n                {\r\n                    binding: 2,\r\n                    resource: { buffer: this.buffers.prefixBlockSum }\r\n                },\r\n                // \"Local shuffle\" optimization needs access to the values buffer\r\n                ...(this.local_shuffle && this.has_values ? [{\r\n                    binding: 3,\r\n                    resource: { buffer: inValues }\r\n                }] : [])\r\n            ]\r\n        })\r\n\r\n        const pipelineLayout = this.device.createPipelineLayout({\r\n            bindGroupLayouts: [ bindGroupLayout ]\r\n        })\r\n\r\n        const blockSumPipeline = this.device.createComputePipeline({\r\n            label: 'radix-sort-block-sum',\r\n            layout: pipelineLayout,\r\n            compute: {\r\n                module: this.shaderModules.blockSum,\r\n                entryPoint: 'radix_sort',\r\n                constants: {\r\n                    'WORKGROUP_SIZE_X': this.workgroup_size.x,\r\n                    'WORKGROUP_SIZE_Y': this.workgroup_size.y,\r\n                    'WORKGROUP_COUNT': this.workgroup_count,\r\n                    'THREADS_PER_WORKGROUP': this.threads_per_workgroup,\r\n                    'ELEMENT_COUNT': this.count,\r\n                    'CURRENT_BIT': bit,\r\n                }\r\n            }\r\n        })\r\n\r\n        return {\r\n            pipeline: blockSumPipeline,\r\n            bindGroup\r\n        }\r\n    }\r\n\r\n    create_reorder_pipeline(inKeys, inValues, outKeys, outValues, bit) {\r\n        const bindGroupLayout = this.device.createBindGroupLayout({\r\n            label: 'radix-sort-reorder',\r\n            entries: [\r\n                {\r\n                    binding: 0,\r\n                    visibility: GPUShaderStage.COMPUTE,\r\n                    buffer: { type: 'read-only-storage' }\r\n                },\r\n                {\r\n                    binding: 1,\r\n                    visibility: GPUShaderStage.COMPUTE,\r\n                    buffer: { type: 'storage' }\r\n                },\r\n                {\r\n                    binding: 2,\r\n                    visibility: GPUShaderStage.COMPUTE,\r\n                    buffer: { type: 'read-only-storage' }\r\n                },\r\n                {\r\n                    binding: 3,\r\n                    visibility: GPUShaderStage.COMPUTE,\r\n                    buffer: { type: 'read-only-storage' }\r\n                },\r\n                ...(this.has_values ? [\r\n                    {\r\n                        binding: 4,\r\n                        visibility: GPUShaderStage.COMPUTE,\r\n                        buffer: { type: 'read-only-storage' }\r\n                    },\r\n                    {\r\n                        binding: 5,\r\n                        visibility: GPUShaderStage.COMPUTE,\r\n                        buffer: { type: 'storage' }\r\n                    }\r\n                ] : [])\r\n            ]\r\n        })\r\n\r\n        const bindGroup = this.device.createBindGroup({\r\n            layout: bindGroupLayout,\r\n            entries: [\r\n                {\r\n                    binding: 0,\r\n                    resource: { buffer: inKeys }\r\n                },\r\n                {\r\n                    binding: 1,\r\n                    resource: { buffer: outKeys }\r\n                },\r\n                {\r\n                    binding: 2,\r\n                    resource: { buffer: this.buffers.localPrefixSum }\r\n                },\r\n                {\r\n                    binding: 3,\r\n                    resource: { buffer: this.buffers.prefixBlockSum }\r\n                },\r\n                ...(this.has_values ? [\r\n                    {\r\n                        binding: 4,\r\n                        resource: { buffer: inValues }\r\n                    },\r\n                    {\r\n                        binding: 5,\r\n                        resource: { buffer: outValues }\r\n                    }\r\n                ] : [])\r\n            ]\r\n        })\r\n\r\n        const pipelineLayout = this.device.createPipelineLayout({\r\n            bindGroupLayouts: [ bindGroupLayout ]\r\n        })\r\n\r\n        const reorderPipeline = this.device.createComputePipeline({\r\n            label: 'radix-sort-reorder',\r\n            layout: pipelineLayout,\r\n            compute: {\r\n                module: this.shaderModules.reorder,\r\n                entryPoint: 'radix_sort_reorder',\r\n                constants: {\r\n                    'WORKGROUP_SIZE_X': this.workgroup_size.x,\r\n                    'WORKGROUP_SIZE_Y': this.workgroup_size.y,\r\n                    'WORKGROUP_COUNT': this.workgroup_count,\r\n                    'THREADS_PER_WORKGROUP': this.threads_per_workgroup,\r\n                    'ELEMENT_COUNT': this.count,\r\n                    'CURRENT_BIT': bit,\r\n                }\r\n            }\r\n        })\r\n\r\n        return {\r\n            pipeline: reorderPipeline,\r\n            bindGroup\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Encode all pipelines into the current pass\r\n     * \r\n     * @param {GPUComputePassEncoder} pass \r\n     */\r\n    dispatch(pass) {\r\n        if (!this.check_order) {\r\n            this.#dispatchPipelines(pass)\r\n        }\r\n        else {\r\n            this.#dispatchPipelinesIndirect(pass)\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Dispatch workgroups from CPU args\r\n     */\r\n    #dispatchPipelines(pass) {\r\n        for (let i = 0; i < this.bit_count / 2; i++) {\r\n            const { blockSumPipeline, reorderPipeline } = this.pipelines[i]\r\n            \r\n            pass.setPipeline(blockSumPipeline.pipeline)\r\n            pass.setBindGroup(0, blockSumPipeline.bindGroup)\r\n            pass.dispatchWorkgroups(this.dispatchSize.x, this.dispatchSize.y, 1)\r\n\r\n            this.kernels.prefixSum.dispatch(pass)\r\n\r\n            pass.setPipeline(reorderPipeline.pipeline)\r\n            pass.setBindGroup(0, reorderPipeline.bindGroup)\r\n            pass.dispatchWorkgroups(this.dispatchSize.x, this.dispatchSize.y, 1)\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Dispatch workgroups from indirect GPU buffers\r\n     */\r\n    #dispatchPipelinesIndirect(pass) {\r\n        for (let i = 0; i < this.bit_count / 2; i++) {\r\n            const { blockSumPipeline, reorderPipeline } = this.pipelines[i]\r\n\r\n            if (this.check_order && i % 2 == 0) {\r\n                this.kernels.checkSortFast.dispatch(pass, this.buffers.dispatchSize, this.dispatchOffsets.check_sort_fast)\r\n                this.kernels.checkSortFull.dispatch(pass, this.buffers.checkSortFullDispatchSize)\r\n            }\r\n            \r\n            pass.setPipeline(blockSumPipeline.pipeline)\r\n            pass.setBindGroup(0, blockSumPipeline.bindGroup)\r\n            pass.dispatchWorkgroupsIndirect(this.buffers.dispatchSize, this.dispatchOffsets.radix_sort)\r\n\r\n            this.kernels.prefixSum.dispatch(pass, this.buffers.dispatchSize, this.dispatchOffsets.prefix_sum)\r\n\r\n            pass.setPipeline(reorderPipeline.pipeline)\r\n            pass.setBindGroup(0, reorderPipeline.bindGroup)\r\n            pass.dispatchWorkgroupsIndirect(this.buffers.dispatchSize, this.dispatchOffsets.radix_sort)\r\n        }\r\n    }\r\n}\r\n\r\nexport default RadixSortKernel"],"names":["prefixSumSource","prefixSumNoBankConflictSource","find_optimal_dispatch_size","device","workgroup_count","dispatchSize","x","y","limits","maxComputeWorkgroupsPerDimension","Math","floor","sqrt","ceil","create_buffer_from_data","_ref","label","data","_ref$usage","usage","dispatchSizes","createBuffer","size","length","mappedAtCreation","dispatchData","Uint32Array","getMappedRange","set","unmap","PrefixSumKernel","count","_ref$workgroup_size","workgroup_size","_ref$avoid_bank_confl","avoid_bank_conflicts","_classCallCheck","threads_per_workgroup","items_per_workgroup","log2","Error","concat","pipelines","shaderModule","createShaderModule","code","prefixSumSource_NoBankConflict","create_pass_recursive","_createClass","key","value","blockSumBuffer","GPUBufferUsage","STORAGE","COPY_SRC","COPY_DST","bindGroupLayout","createBindGroupLayout","entries","binding","visibility","GPUShaderStage","COMPUTE","buffer","type","bindGroup","createBindGroup","layout","resource","pipelineLayout","createPipelineLayout","bindGroupLayouts","scanPipeline","createComputePipeline","compute","module","entryPoint","constants","push","pipeline","blockSumPipeline","get_dispatch_chain","flatMap","p","dispatch","pass","dispatchSizeBuffer","offset","arguments","undefined","i","_this$pipelines$i","setPipeline","setBindGroup","dispatchWorkgroups","dispatchWorkgroupsIndirect","radixSortSource","radixSortCoalescedSource","radixSortReorderSource","checkSortSource","isFirstPass","isLastPass","isFullCheck","first_pass_load_data","last_pass","write_reduction_result","last_pass_full","last_pass_fast","CheckSortKernel","result","original","is_sorted","_ref$start","start","_ref$full_check","full_check","buffers","outputs","create_passes_recursive","passIndex","outputBuffer","_toConsumableArray","element_count","start_element","checkSortPipeline","dispatchIndirect","find_optimal_dispatch_chain","item_count","sizes","target_workgroup_count","_RadixSortKernel_brand","WeakSet","RadixSortKernel","keys","values","_ref$bit_count","bit_count","_ref$check_order","check_order","_ref$local_shuffle","local_shuffle","_classPrivateMethodInitSpec","Number","isInteger","prefix_block_workgroup_count","has_values","shaderModules","kernels","create_shader_modules","create_pipelines","remove_values","source","split","filter","line","toLowerCase","includes","join","blockSumSource","radixSortSource_LocalShuffle","blockSum","reorder","reorderSource","create_prefix_sum_kernel","calculate_dispatch_sizes","create_buffers","create_check_sort_kernels","bit","even","inKeys","tmpKeys","inValues","tmpValues","outKeys","outValues","create_block_sum_pipeline","reorderPipeline","create_reorder_pipeline","prefixBlockSumBuffer","prefixSumKernel","prefixSum","prefixBlockSum","prefixSumDispatchSize","check_sort_fast_count","min","check_sort_full_count","start_full","dispatchSizesFast","dispatchSizesFull","initialDispatch","slice","dispatchOffsets","radix_sort","check_sort_fast","prefix_sum","tmpKeysBuffer","tmpValuesBuffer","localPrefixSumBuffer","localPrefixSum","dispatchBuffer","INDIRECT","originalDispatchBuffer","checkSortFullDispatchBuffer","checkSortFullOriginalDispatchBuffer","isSortedBuffer","originalDispatchSize","checkSortFullDispatchSize","originalCheckSortFullDispatchSize","isSorted","checkSortPartitionData","checkSortFull","checkSortFast","console","warn","_assertClassBrand","_dispatchPipelines","call","_dispatchPipelinesIndirect","_this$pipelines$i2"],"mappings":"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"}